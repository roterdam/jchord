\documentclass{article}
\usepackage{hyperlatex}

%\topmargin=-0.5in
\texonly{\oddsidemargin=0in}
\texonly{\evensidemargin=0in}
\texonly{\textwidth=5.6in}
%\textheight=8.5in

%TODO: specify use of BDD's under efficiency in section 1 (overview)

\htmlmathitalic{0}
\htmltitle{User Guide}
\htmladdress{chord@cs.stanford.edu, \today}

\providecommand\Mdom{{\bf M}}
\providecommand\Idom{{\bf I}}
\providecommand\Vdom{{\bf V}}
\providecommand\Zdom{{\bf Z}}
\providecommand\Hdom{{\bf H}}
\providecommand\Edom{{\bf E}}
\providecommand\Fdom{{\bf F}}
\providecommand\Cdom{{\bf C}}
\providecommand\Tdom{{\bf T}}
\providecommand\Pdom{{\bf P}}
\providecommand\Sdom{{\bf S}}

\providecommand\instM{{\bf instM}}
\providecommand\statM{{\bf statM}}
\providecommand\MH{{\bf MH}}
\providecommand\MI{{\bf MI}}
\providecommand\ME{{\bf ME}}

\providecommand\cha{{\bf cha}}
\providecommand\sub{{\bf sub}}
\providecommand\HT{{\bf HT}}
\providecommand\VT{{\bf VT}}
\providecommand\EF{{\bf EF}}
\providecommand\writeE{{\bf writeE}}

\providecommand\virtIM{{\bf virtIM}}
\providecommand\statIM{{\bf statIM}}
\providecommand\specIM{{\bf specIM}}

\providecommand\MmethArg{{\bf MmethArg}}
\providecommand\MmethRet{{\bf MmethRet}}
\providecommand\IinvkArg{{\bf IinvkArg}}
\providecommand\IinvkRet{{\bf IinvkRet}}
\providecommand\MordMethArg{{\bf MordMethArg}}
\providecommand\MspcMethArg{{\bf MspcMethArg}}

\providecommand\MobjVarAsgnInst{{\bf MobjVarAsgnInst}}
\providecommand\MclsVarAsgnInst{{\bf MclsVarAsgnInst}}
\providecommand\MobjValAsgnInst{{\bf MobjValAsgnInst}}
\providecommand\MgetInstFldInst{{\bf MgetInstFldInst}}
\providecommand\MputInstFldInst{{\bf MputInstFldInst}}
\providecommand\MgetStatFldInst{{\bf MgetStatFldInst}}
\providecommand\MputStatFldInst{{\bf MputStatFldInst}}

\providecommand\syncMV{{\bf syncMV}}
\providecommand\nestedLocks{{\bf nestedLocks}}

\providecommand\VH{{\bf VH}}
\providecommand\FH{{\bf FH}}
\providecommand\HFH{{\bf HFH}}
\providecommand\IM{{\bf IM}}

\providecommand\forkC{{\bf forkC}}

\providecommand\CVC{{\bf CVC}}
\providecommand\FC{{\bf FC}}
\providecommand\CFC{{\bf CFC}}
\providecommand\CICM{{\bf CICM}}
\providecommand\CHC{{\bf CHC}}

\providecommand\clinitM{{\bf clinitM}}

\providecommand\Chord{{Chord}}

\providecommand\NameToTrgtMap{{\tt NameToTrgtMap}}
\providecommand\NameToTaskMap{{\tt NameToTaskMap}}
\providecommand\ConsumedNameToTasksMap{{\tt ConsumedNameToTasksMap}}
\providecommand\TaskGraph{{\tt TaskGraph}}
\providecommand\TaskMapEntries{{\tt TaskMapEntries}}
\providecommand\TrgtMapEntries{{\tt TrgtMapEntries}}
\providecommand\DlogMapEntries{{\tt DlogMapEntries}}
\providecommand\Tasks{{\tt Tasks}}
\providecommand\Trgts{{\tt Trgts}}
\providecommand\ValidTasks{{\tt ValidTasks}}
\providecommand\TrgtNames{{\tt TrgtNames}}

\title{Chord: A Static Analysis Framework for Java}
\author{Mayur Naik and Alex Aiken}
\date{\today}
\begin{document}
\maketitle
\texonly{\tableofcontents}

\texonly{\newpage}
\section{Overview}

\Chord\ is a static analysis framework for Java with an emphasis on the analysis of objects and concurrency.
It has the following characteristics:
\begin{enumerate}
\item
It is {\it stand-alone} in that it provides various off-the-shelf static analyses (e.g., may alias analysis, thread escape analysis, datarace analysis, deadlock analysis, etc.).
\item
It is {\it extensible} in that it allows users to build their own static analyses on top of the provided static analyses.
\item
It is {\it compositional} in that it enables different static analyses to coexist and interact with each other.
\item
It is {\it efficient} in that it
caches results computed by each static analysis so that they can be reused by other static analyses without re-computation.
\item
It is {\it flexible} in that it allows each static analysis to be expressed either declaratively as a Datalog program or imperatively as a Java program.
\end{enumerate}

\texonly{\newpage}
\section{Download and Installation}

Before installing \Chord\ ensure that the following software is installed on your machine:

\begin{itemize}
\item
JDK 5 or higher (e.g., from
Sun\footnote{\xlink{{\tt http://java.sun.com/javase/downloads/index.jsp}}{http://java.sun.com/javase/downloads/index.jsp}}
or IBM\footnote{\xlink{{\tt http://www.ibm.com/developerworks/java/jdk/}}{http://www.ibm.com/developerworks/java/jdk/}}).

\item
Apache Ant (a Java build tool)\footnote{\xlink{{\tt http://ant.apache.org/}}{http://ant.apache.org/}}
\end{itemize}

Download the latest version of \Chord\ from \xlink{{\tt http://code.google.com/p/jchord/}}{http://code.google.com/p/jchord/}
(say {\tt chord-x.y.tar.gz}) and uncompress it in a suitable directory by running the following command:

\begin{verbatim}
tar xvzf chord-x.y.tar.gz
\end{verbatim}

This will create a directory structure with root directory {\tt chord-x.y/}.

\texonly{\newpage}
\section{Building Chord}

The root directory {\tt chord-x.y/} contains a {\tt build.xml} file which is interpreted by
Apache Ant (a Java build tool).
To see the various targets available run the following command in the root directory:

\begin{verbatim}
ant -p
\end{verbatim}

The default target {\tt compile} compiles \Chord.  So simply run the following command in the
root directory:

\begin{verbatim}
ant
\end{verbatim}

This will compile the \Chord\ {\tt .java} source files and store the {\tt .class} files
under the {\tt classes/} sub-directory of the root directory.

\texonly{\newpage}
\section{Running Chord}

Suppose the program to be analyzed has the following directory structure:

\begin{verbatim}
example/
    src/
        foo/
            Main.java
            ...
    classes/
        foo/
            Main.class
            ...
    lib/
        src/
            taz/
                ...
        jars/
            taz.jar
    chord/
        chord.properties
\end{verbatim}

The above structure is typical: the program's Java source files are under {\tt example/src/}, its class files
are under {\tt example/classes/}, the source and jar files of the libraries used by the program are under
{\tt example/lib/src/} and {\tt example/lib/jars/}, respectively, and finally {\tt example/chord/} is the directory
to which Chord will output its intermediate and final results.

Execute Chord on the above program by running the
following command in Chord's root directory {\tt chord-x.y/}:

\begin{verbatim}
ant -Dchord.work.dir=.../example/chord run
\end{verbatim}

where ``{\tt ...}'' denotes either the absolute path, or the path relative to Chord's root directory,
of the parent of directory {\tt example/}.
Chord will read the system properties specified in the file named {\tt chord.properties}
that it presumes exists in the directory specified
by system property {\tt chord.work.dir}
which in the above case is directory {\tt example/chord/}.
A sample such file for the above program is as follows:

\begin{verbatim}
chord.main.class=foo.Main
chord.class.path=../classes:../lib/classes/taz.jar
chord.src.path=../src:../lib/src
chord.out=log.txt
chord.err=log.txt
chord.serial.file=program.ser
chord.java.analysis.path=${chord.home.dir}/classes/main:
    ${chord.home.dir}/classes/downcast:${chord.home.dir}/src/dlog/monosite
chord.dlog.analysis.path=${chord.home.dir}/src/dlog/main:
    ${chord.home.dir}/src/dlog/downcast:${chord.home.dir}/src/dlog/monosite
chord.analyses=downcast-java,monosite-java
\end{verbatim}

System property {\tt chord.home.dir} specifies Chord's root directory
{\tt chord-x.y/}.
Every non-absolute location used in the value of any system property defined in the file
is taken to be relative to the directory specified by system
property {\tt chord.work.dir}.

Section \ref{sec-sys-prop} presents an exhaustive
listing of system properties that are recognized by \Chord.
Briefly:
\begin{itemize}
\item
{\tt chord.main.class} specifies the main class of the program
to be analyzed.
\item
{\tt chord.class.path} specifies the application classpath of the program to be analyzed (as opposed to the
JDK library classpath which consists of jar files such as {\tt rt.jar}
which are implicitly appended to the program's application classpath to yield the
complete program classpath).
\item
{\tt chord.out} and {\tt chord.err} specify the files (typically one and the same) to which the standard output and
standard error streams, respectively, must be redirected while running Chord.
\item
{\tt chord.serial.file} specifies the location of a file from (resp. to) which
the serialized form of the intermediate representation of the program to be analyzed must be loaded (resp. stored).
This option is provided because loading the serialized form is much faster than
constructing the intermediate representation of the program each time.
\item
{\tt chord.java.analysis.path} and {\tt chord.dlog.analysis.path} 
specify all program domains, program relations, and program analyses
to be included in the project and the
dependencies between them (see Section \ref{sec-tg}).
In the above case, they specify certain
 program domains, program relations, and program analyses
pre-defined in \Chord, in particular, all those in (1) Chord's standard library, (2) Chord's downcast safety
analysis, and (3) Chord's monomorphic call site analysis.
Users can also define their own
program domains, program relations, and program analyses and include them in the project.
\item
{\tt chord.analyses} is a space- or comma-separated list of the names of program domains,
program relations, and program analyses that must be run in that order.  In the above case,
these are downcast safety analysis, denoted {\tt downcast-java}, and monomorphic call site analysis,
denoted {\tt monosite-java}.
Both are program analyses pre-defined in \Chord\ 
but users can also include the names
of program domains, program relations, and program analyses they have defined and wish to run.
\end{itemize}

\texonly{\newpage}
\section{Specifying Program Scope}

\Chord\ takes as input a complete (i.e., closed) program with a main method.
The scope of the program must be specified in one of the
following ways:

\begin{itemize}
\item
Defining system property {\tt chord.serial.file} as
the location of a file containing in serialized form the intermediate representation
of the program generated by a previous run of \Chord.
\item
Defining system property {\tt chord.main.class} as the fully-qualified name
of the program's main class (e.g., {\tt foo.Main}) and system property
{\tt chord.class.path} as the program's application classpath.
\end{itemize}

The former option is provided because loading the serialized form
is much faster than constructing the intermediate representation
of the program each time.

\Chord\ first checks whether system property {\tt chord.serial.file} is defined.
If it is defined, then it further checks whether the file specified by it
exists.
If the file exists, then \Chord\ treats the file as a serialized form of
the intermediate representation of the program to be analyzed, and loads it.

If system property {\tt chord.serial.file} is not defined or if the file
specified by the property does not exist, then \Chord\ requires system properties
{\tt chord.main.class} and {\tt chord.class.path} 
to be defined, and uses them to
build an intermediate representation of the program (see Section \ref{sec-prog-build})
and perform source-to-source transformations on that representation
(see Section \ref{sec-prog-transform}) that simplify several program analyses.
Finally, if system property {\tt chord.serial.file} was defined but
specified a non-existent file, then \Chord\ creates the file and stores the
transformed intermediate representation of the program into the file in
serialized form so that it can be loaded in subsequent runs.

Defining system property {\tt chord.src.path} is optional.
It specifies the program's Java source path which provides the
locations of the program's {\tt .java} files so that, for instance, the
results of an analysis (which operates on the intermediate representation of
the program extracted from {\tt .class} files) can be mapped to the
program's {\tt .java} files and presented to the user for
manual inspection.

\texonly{\newpage}
\section{Program Representation}
\label{sec-prog-build}

Given the program's program's main class via system property {\tt chord.main.class} and the
program's application classpath via system property {\tt chord.class.path},
\Chord\ uses system property {\tt chord.program.builder.class} to locate the
builder to be used for building an intermediate representation of the program,
namely, an object of class {\tt chord.program.Program}.
By default, the value of this property is class {\tt chord.program.builders.SootProgramBuilder}
which uses the Soot Java compiler framework \cite{Soot}.
Any builder, however, must implement interface
{\tt chord.program.builders.IProgramBuilder}.

The intermediate representation
elides values of primitive type (e.g., int, boolean, etc.) and operations
on them (e.g., arithmetic and relational operations) in the original program.
The current emphasis of \Chord\ is on the analysis of objects
but the analysis of primitives may be supported in future
releases.

The intermediate representation represents the program as a set of types.
Each type has a set of (instance or static) fields and a set of
(instance or static) methods.
Each method has an optional control-flow graph.
The control-flow graph has a unique entry point and
a unique exit point\footnote{Even the control-flow graph of a method with an infinite loop
has an exit point because loops are transformed into tail-recursive methods
(see Section \ref{sec-prog-transform}).}.
The entry and exit points are always distinct.
Each point in the control-flow graph has one or more immediate predecessors
(except the entry point which has none) and, likewise,
one or more immediate successors (except the exit point which has none).
Associated with each point is a simple statement, which may be of one of
the following kinds:

\begin{itemize}
\item
{\tt HeadInst}

The statement associated with the unique entry point of a control-flow graph.

It serves as a placeholder for:

\begin{itemize}
\item
the (possibly empty) list of the method's {\it argument variables} of reference type;
in the case of an instance method, this list is non-empty,
with the $0^{th}$ element being the distinguished implicit {\tt this}
argument variable.
\item
the (possibly empty) list of the method's {\it temporary variables} of reference type.
\end{itemize}

Argument variables and temporary variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

Argument variables and temporary variables are distinct, namely,
the set of a method's {\it local variables} (of reference type)
is the disjoint union of the sets of the method's argument variables (of reference type) and
temporary variables (of reference type).

\item
{\tt TailInst}

The statement associated with the unique exit point of a control-flow graph.

It serves as a placeholder for 
the (possibly empty) list of the method's {\it return variables} of reference type.

Return variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

The set of a method's return variables (of reference type) is a subset of the set
of the method's local variables (of reference type).

A Java method has at most one return variable but
\Chord's intermediate representation allows multiple return variables
to enable compiling away exceptions, loops, synchronized blocks, etc.

\item
{\tt AcqLockInst}

A statement of the form {\tt monitorenter v} where
{\tt v} is a local variable of reference type.

\item
{\tt RelLockInst}

A statement of the form {\tt monitorexit v} where {\tt v}
is a local variable of reference type.

\item
{\tt StrValAsgnInst}

A statement of the form {\tt v = "..."} where {\tt v} is
a local variable of any reference type that can store a string
constant.  It is typically (but not necessarily) of type
{\tt java.lang.String}.

\item
{\tt NilValAsgnInst}

A statement of the form {\tt v = null} where {\tt v}
is a local variable of reference type.

\item
{\tt StatFldRefInst}

A statement of one of the following forms:

{\tt v = f} \\
{\tt f = v} \\
{\tt * = f} \\
{\tt f = *}

where {\tt v} is a local variable of reference type and
{\tt f} is a static field.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.

\item
{\tt InstFldRefInst}

A statement of one of the following forms:

{\tt v = b.f} \\
{\tt b.f = v} \\
{\tt * = b.f} \\
{\tt b.f = *}

where {\tt v} and {\tt b} are local variables of reference
type and {\tt f} is an instance field.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.

\item
{\tt SkipInst}

A no-op statement.

Due to \Chord's emphasis on the analysis of objects, each statement
in the original program that does not access
any value of reference type (i.e., only accesses values of primitive
type) is represented by this statement.

\item
{\tt InvkInst}

A method invocation statement of the form
{\tt r1,...,rn = m(a1,...,ak)} where
{\tt r1}, ..., {\tt rn} (return variables) and
{\tt a1}, ..., {\tt ak} (argument variables)
are local variables of reference type.

Argument variables and return variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

A method invocation statement in Java has at most
one return variable but
\Chord's intermediate representation allows multiple return variables
to enable compiling away exceptions, loops, synchronized blocks, etc.

\item
{\tt ObjVarAsgnInst}

A statement of the form {\tt v1 = v2} where {\tt v1}
and {\tt v2} are local variables of (possibly different) reference types.

\item
{\tt ObjValAsgnInst}

A statement of the form {\tt v = new t} where {\tt t} is a
concrete reference type and
{\tt v} is a local variable of a (possibly different) reference type.

\item
{\tt ClsVarAsgnInst}

A statement of the form {\tt v = b.getClass()} where
{\tt v} is a local variable of type {\tt java.lang.Class}
and {\tt b} is a local variable of reference type.

The reason this kind of statement is modeled is because
\Chord\ has an emphasis on concurrency and many Java programs
hold locks on the runtime class of an object
(which is obtained by calling the native {\tt getClass}
instance method of the object).

\item
{\tt AryElemRefInst}

A statement of one of the following forms:

{\tt v = b[*]}  \\
{\tt b[*] = v} \\
{\tt * = b[*]} \\
{\tt b[*] = *}

where {\tt v} and {\tt b} are local variables of reference
type.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.
\end{itemize}

\texonly{\newpage}
\section{Program Transformations}
\label{sec-prog-transform}

After building the intermediate representation of the
program, \Chord\ performs
the following source-to-source transformations 
that simplify several program analyses:

\begin{enumerate}
\item
{\bf Sync Removal}

Removes all synchronized blocks from each method M in each class
C in the program by generating a fresh static method (in class C)
per synchronized block in the body of M.

\item
{\bf Loop Removal}

Removes all loops from each method M in each class C in the program
by generating a fresh static method (in class C)
per loop in the body of M.

\item
{\bf Skip Removal}

Removes all skip (i.e., no-op) statements from each method in each class
in the program.
Such statements arise primarily because \Chord, due to its emphasis
on the analysis of objects, replaces each
statement in the original program that does not access any
value of reference type (i.e., only accesses values of primitive
type) by a skip statement.

\end{enumerate}

\texonly{\newpage}
\section{Task Graph Construction}
\label{sec-tg}

\Chord\ requires the following three system properties to construct the task graph:

\begin{enumerate}
\item
{\tt chord.dlogmap.path}

The path specifying the mapping from the name of each Datalog-based program
analysis that must be included in the project to the location
of the file defining that program analysis.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <file-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:' on UNIX and `;' on Windows).

Let \DlogMapEntries\ denote the set of all entries of the
above form.

\item
{\tt chord.trgtmap.path}

The path partially specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be
included in the project to the fully-qualified name of a subclass, either
pre-defined in \Chord\ or defined by the user, of {\tt chord.Dom},
{\tt chord.Ary*Rel}, and
{\tt chord.Entity}, respectively, the instance fields of which define the
state of the corresponding domain, relation, or analysis.
The `{\tt *}' in {\tt chord.Ary*Rel} is 1, 2, ..., 6, or N for
program relations of arity 1, 2, ..., 6, or $>$ 6, respectively.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:` on UNIX and ';' on Windows).

Let \TaskMapEntries\ denote the set of all entries of the
above form.

\item
{\tt chord.taskmap.path}

The path partially specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be included in
the project to the fully-qualified name of a
subclass, either pre-defined in \Chord\ or defined by the user, of
{\tt chord.Dom}, {\tt chord.Ary*Rel}, and {\tt chord.Entity}, respectively,
which define the following instance methods:
\begin{itemize}
\item
the {\tt execute} method specifying
the computation that updates the state of the corresponding domain, relation,
or analysis,
\item
the {\tt invalidate} method specifying the action to be taken when the
state of the corresponding domain, relation, or analysis is invalidated.
\item
the {\tt getConsumedNames} method specifying names of any domains, relations,
and Datalog-based or Java-based program analyses upon whose state the
computation depends, and
\item
the {\tt getProducedNames} method specifying names of any domains, relations,
and Datalog-based or Java-based program analyses whose state depends upon
the computation.
\end{itemize}

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:` on UNIX and ';' on Windows).

Let \TrgtMapEntries\ denote the set of all entries of the above form.
\end{enumerate}

Then, \Chord\ uses the values of \DlogMapEntries, \TaskMapEntries, and \TrgtMapEntries\ 
to do the following:

\begin{enumerate}
\item
Compute {\tt Tasks\ :\ Set<chord.Entity>}, the set of all tasks,
each of which is an object of (a subclass of) {\tt chord.Entity},
as follows:

\begin{enumerate}
\item
For each entry in \DlogMapEntries\ (i.e., a Datalog-based program analysis,
there is a unique task, namely, a unique object of class {\tt chord.DatalogAnalysis}.

\item
For each entry in \TaskMapEntries\ (i.e., of the form {\tt <name> <class-name>} specifying
a program domain, a program relation, or a Java-based program analysis), there is a
unique task, namely, a unique object
of the class named {\tt <class-name>} which must be (a subclass of) {\tt chord.Dom} in the
case of a program domain, (a subclass of) {\tt chord.Ary*Rel} in the case of a
program relation, and (a subclass of) {\tt chord.Entity} in the case of a Java-based
program analysis.
\end{enumerate}

\item
Compute the following maps as shown below:

{\tt ConsumedNameToTasksMap\ :\ String -> Set<Task>},
mapping each name to the set of (possibly empty) tasks that consume that name.

{\tt NameToTaskMap\ :\ String -> Task},
mapping each name to the unique task that produces that name.

\Chord\ reports an error if a name is produced by no task or by more than one task.
{\small 
\begin{verbatim}
for each (<task> in Tasks) {
    case <task> came from item 1(a) above: {
        // <task> corresponds to a Datalog-based program analysis
        for each (<name> declared as input relation) {
            add <task> to ConsumedNameToTasksMap(<name>)
        }
        for each (<name> declared as output relation) {
            if (<name> is in domain of map NameToTaskMap)
                error ``multiple tasks produce name <name>''
            else
                NameToTaskMap(<name>) = <task>
        }
    }
    case <task> came from item 1(b) above: {
        // <task> corresponds to a program domain, a program relation, or
        // a Java-based program analysis
        // Suppose <task> came from entry <name> <class-name> in
        // TaskMapEntries
        // i.e. <task> is an object of class named <class-name>
        for each (<name2> in <task>.getConsumedNames())
            add <task> to ConsumedNameToTaskMaps(<name2>)
        for each (<name2> in <task>.getProducedNames() union { <name> })
            if (<name2> is in domain of map NameToTaskMap)
                error ``multiple tasks produce name <name>''
            else
                NameToTaskMap(<name2>) = <task>
    }
}
\end{verbatim}
}

{\small 
\begin{verbatim}
for each (<name> in domain of map ConsumedNameToTasksMap) {
    if (<name> is not in domain of map NameToTaskMap)
        error ``no task produces name <name>''
}
\end{verbatim}
}

\item
Compute \NameToTrgtMap : {\tt String -> Entity},
mapping each name to a unique target, as below.
\Chord\ reports an error if a name is mapped to multiple targets
or to no target.

{\small 
\begin{verbatim}
for each (entry <name> <class-name> in TaskMapEntries) {
    if (<name> is in domain of map NameToTrgtMap)
        error ``name <name> mapped to multiple targets''
    NameToTrgtMap(<name>) = NameToTaskMap(<name>)
}
for each (entry <name> <class-name> in TrgtMapEntries) {
    if (<name> is in domain of map NameToTrgtMap)
        error ``name <name> mapped to multiple targets''
    NameToTrgtMap(<name>) = a fresh object of class named <class-name>
}
\end{verbatim}
}

To reduce user burden in providing \TaskMapEntries\ and
\TrgtMapEntries, \Chord\ implicitly extends \NameToTrgtMap\ using
\DlogMapEntries\ as follows:

{\small 
\begin{verbatim}
for each (<name> in domain of map NameToTaskMap) {
    if (<name> is not in domain of map NameToTrgtMap) {
        if (<name> is declared as a domain in some datalog file in DlogMapEntries)
            NameToTrgtMap(<name>) = a fresh object of class chord.Dom
        else if (<name> is declared as a (input or output) relation
                in some datalog file in DlogMapEntries)
            NameToTrgtMap(<name>) = a fresh object of class chord.Rel
        else
            error ``<name> not mapped to any target''
    } else {
        chord.Entity <trgt> = NameToTrgtMap(<name>)
        if (<name> is declared as a domain in some datalog file in DlogMapEntries
                and <trgt> is not of type (subclass of) chord.Dom)
            error ``<name> has conflicting types''
        else if (<name> is declared as a (input or output) relation
                in some datalog file in DlogMapEntries
                and <trgt> is not of type (subclass of) chord.Rel)
            error ``<name> has conflicting types''
    }
}
\end{verbatim}
}

\item
Compute graph \TaskGraph\ as a graph whose:

\begin{itemize}
\item
set of nodes is \Tasks\ and
\item
set of edges containing an edge from task {\tt <task1>} to task {\tt <task2>} 
whenever there exists a name {\tt <name>} such that
\NameToTaskMap({\tt <name>}) = {\tt <task1>} and
\ConsumedNameToTasksMap({\tt <name>}) contains {\tt <task2>}.
\end{itemize}

The task graph in XML and HTML formats is dumped to files {\tt taskgraph.xml}
and {\tt taskgraph.html} in the project's working directory specified using
system property {\tt chord.work.dir}.

\end{enumerate}

\texonly{\newpage}
\section{Project Organization}

\Chord\ interprets system property {\tt chord.trgts}, if defined, as
a space-separated list of names of program domains, program relations, and
Datalog-based or Java-based program analyses, denoted \TrgtNames,
to be computed in that order.

To avoid redundant computation, \Chord\ maintains during its execution a set of
up-to-date tasks, denoted \ValidTasks,
which is a subset of the set of all tasks, denoted \Tasks.
Set \ValidTasks\ is empty at startup.
A future release of \Chord\ may provide the ability to retrieve a set of up-to-date tasks from
a previous run of \Chord\ to prevent re-computing those tasks in subsequent runs.
The following procedure is executed upon startup:

{\small
\begin{verbatim}
for each (<name> in TrgtNames in order) {
    if (<name> is not in domain of map NameToTaskMap) {
        error ``name <name> is an invalid target name''
    else {
        chord.Entity <task> = NameToTaskMap(<name>)
        executeTask(<task>)
    }
}
\end{verbatim}
}

\noindent where procedure {\tt executeTask} is defined as follows:

{\small
\begin{verbatim}
procedure executeTask(chord.Entity <task>) {
    if (<task> is not in ValidTasks) {
        for each (immed. pred. <task2> of <task> in TaskGraph)
            executeTask(<task2>)
        <task>.execute()
        for each (immed. succ. <task2> of <task> in TaskGraph)
            invalidateTask(<task2>)
        add <task> to ValidTasks
    }
}
\end{verbatim}
}

\noindent where procedure {\tt invalidateTask} is defined as follows:

{\small
\begin{verbatim}
procedure invalidateTask(chord.Entity t) {
    if (<task> is in ValidTasks) {
        remove <task> from ValidTasks
        <task>.invalidate()
        for each (immed. succ. <task2> of <task> in TaskGraph)
            invalidateTask(<task2>)
    }
}
\end{verbatim}
}

\texonly{\newpage}
\section{Chord System Properties}
\label{sec-sys-prop}

\Chord\ recognizes the following system properties:

\begin{itemize}
\item
{\tt chord.out}

The location of a file to which the standard output stream
of \Chord's execution is redirected.

It may be the same file to which the standard error stream is redirected (see
the description of system property {\tt chord.err}).

The file is created if it does not exist and its contents are overwritten if it exists.

\item
{\tt chord.err}

The location of a file to which the standard error stream
of \Chord's execution is redirected.

It may be the same file to which the standard output stream is redirected (see
the description of system property {\tt chord.out}).

The file is created if it does not exist and its contents are overwritten if it exists.

\item
{\tt chord.program.builder.class}

The fully-qualified name of the class to be used for building the
intermediate representation of the program to be analyzed.
It must be a concrete class with a nullary constructor that
implements interface {\tt chord.program.builders.IProgramBuilder}.

The default value of this property is {\tt chord.program.builders.SootProgramBuilder}
which uses the Soot Java compiler framework \cite{Soot}.

\item
{\tt chord.serial.file}

The location of a file from (resp.\ to) which
the serialized form of the intermediate representation of the
program to be analyzed is loaded (resp.\ stored).

\item
{\tt chord.main.class}

The fully-qualified name of the main class (e.g., {\tt foo.Main}) of the
program to be analyzed.

This system property (and {\tt chord.class.path})
must be defined if system property {\tt chord.serial.file}
does not specify the file containing the serialized form of the intermediate representation
of the program to be analyzed.

\item
{\tt chord.class.path}

The application classpath of the program to be analyzed (as opposed to the
JDK library classpath which consists of jar files such as {\tt rt.jar}
which are implicitly appended to the program's application classpath to
yield the complete program classpath).

Each path element must be the location of a directory or a jar/zip file.

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

This system property (and {\tt chord.main.class}) must
be defined if system property {\tt chord.serial.file}
does not specify the file containing the serialized form of the intermediate representation
of the program to be analyzed.

\item
{\tt chord.src.path}

The Java source path of the program to be analyzed.

Each path element must be the location of a directory.

The purpose of this path is to provide the location of the
{\tt .java} files of the program being analyzed so that, for instance, the
results of an analysis (which operates on an intermediate representation of the program
extracted from {\tt .class} files) can be mapped to the corresponding {\tt .java}
files and presented to the user for manual inspection.

Each file having suffix {\tt .java} in a directory (or a sub-directory of a directory)
specified in this path is regarded as a source file of the program.

\item
{\tt chord.dlog.analysis.path}

The path specifying the mapping from the name of each Datalog-based program
analysis that must be included in the project to the location
of the file defining that program analysis.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <file-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

\item
{\tt chord.java.analysis.path}

The path specifying the mapping from the name of each program domain, program relation,
and Java-based program analysis that must be included in the project to the
fully-qualified name of a subclass, either pre-defined in \Chord\ or defined by the user, of
{\tt chord.Dom}, {\tt chord.Ary*Rel}, and {\tt chord.Entity}, respectively, which
define the following instance methods:
\begin{itemize}
\item
the {\tt execute} method specifying
the computation that updates the state of the corresponding domain, relation,
or analysis, 
\item
the {\tt invalidate} method specifying the action to be taken when the
state of the corresponding domain, relation, or analysis is invalidated.
\item
the {\tt getConsumedNames} method specifying names of any domains, relations,
and analyses upon whose state the computation depends, and
\item
the {\tt getProducedNames} method specifying names of any domains, relations,
and analyses whose state depends upon the computation.
\end{itemize}

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

\item
{\tt chord.trgtmap.path}

The path specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be
included in the project to the fully-qualified name of a subclass,
either pre-defined in \Chord\ or defined by the user, of {\tt chord.Dom},
{\tt chord.Ary*Rel}, and
{\tt chord.Entity}, respectively, the instance fields of which define the
state of the corresponding domain, relation, or analysis.

Each path element in the list must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:` on UNIX and ';' on Windows).

\item
{\tt chord.analyses}

A space-separated list of the names of program domains, program relations, and
Java-based or Datalog-based program analyses that must be computed in that order.

\item
{\tt chord.ext.class.path}

The classpath of user-defined program domains, user-defined program relations,
and user-defined Java-based program analyses.
It is implicitly appended to the classpath of pre-defined program domains,
pre-defined program relations, and pre-defined Java-based program analyses
to yield the complete runtime classpath of \Chord.

Each path element must be the location of a directory or a jar/zip file.

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).
\end{itemize}

\texonly{\newpage}
\section{Pre-defined Domains}
\label{sec-predef-domains}

The following domains are pre-defined in \Chord:

\begin{itemize}
\item
$\Cdom$

The domain of all k-object-sensitive contexts.

The $0^{th}$ element in this domain denotes a distinguished hypothetical
context (denoted \texorhtml{$\epsilon$}{{\it epsilon}} in the literature) that is regarded as the
lone abstract context in which certain static methods are analyzed.
The main static method with signature {\tt void main(java.lang.String[])}
has no callers and is therefore analyzed in this context.
For simplicity, the k-object-sensitive may alias analysis provided in
\Chord\ also analyzes each class initializer method in this context.

\item
$\Edom$

The domain of all statements that access (read or write) an instance field,
a static field, or an array element, namely, all statements
represented by instances of (subclasses of) {\tt chord.program.insts.HeapInst}.

\item
$\Fdom$

The domain of  all instance and static fields.

The $0^{th}$ element in this domain denotes a distinguished hypothetical
field that is regarded as accessed whenever an array element is
accessed.

\item
$\Hdom$

The domain of all object allocation statements, namely, all statements
represented by instances of {\tt chord.program.insts.ObjValAsgnInst}.

\item
$\Idom$

The domain of all method invocation statements, namely, all statements
represented by instances of {\tt chord.program.insts.InvkInst}.

\item
$\Mdom$

The domain of all instance and static methods.

The $0^{th}$ element in this domain is the main method of the program.

The $1^{st}$ element in this domain is the method with signature
{\tt void start()} of class {\tt java.lang.Thread}, if this
method is deemed reachable from the main method of the program.

The above two methods are the root methods of the implicitly spawned
main thread and each explicitly spawned child thread, respectively.
Due to \Chord's emphasis on concurrency, these methods are
referenced frequently by various pre-defined program analyses
expressed in Datalog, and giving them special indices makes it
convenient to reference them in those analyses.

\item
$\Pdom$

The domain of all simple statements, namely, all statements
represented by instances of (subclasses of) {\tt chord.program.insts.Inst}.

The $0^{th}$ element in this domain is the statement at the unique
entry point of the main method of the program.

The statements of each method in the program are assigned
contiguous indices in this domain, with the statements at the
unique entry and exit points of each method being assigned
the smallest and largest indices, respectively, of all
indices assigned to statements in that method.

\item
$\Tdom$

The domain of all types, including the types of classes, interfaces,
arrays, and primitives.

\item
$\Vdom$

The domain of all local variables.

Each local variable declared in each block of each method is
represented by a unique element in this domain, in particular,
local variables that have the same name but are declared in
different methods or in different blocks of the same method
are represented by different elements in this domain.

All local variables of the same method are assigned contiguous
indices in this domain, in particular, the set of local
variables of a method is the disjoint union of its argument
variables and its temporary variables, and the argument
variables are assigned contiguous indices in order followed by
the temporary variables.

\item
$\Zdom$

The domain of all argument and return variable positions.
Let $N$ be the largest number or arguments or return variables of any
method.  Then, this domain contains the $N$ elements $0, 1, ..., N-1$.
\end{itemize}

\texonly{\newpage}
\section{Pre-defined Relations}
\label{sec-predef-relations}

The following relations are pre-defined in \Chord:

\begin{itemize}

\item
$\cha : \Mdom \times \Tdom \times \Mdom$

Relation containing each tuple $(m_1,t,m_2)$ such that $m_2$ is
the target method of a method invocation statement whose {\it resolved method}
is $m_1$ and whose receiver has run-time type $t$.
It is named $\cha$ because it represents the relation
computed by Class Hierarchy Analysis.

\item
$\sub : \Tdom \times \Tdom$

Relation containing each tuple $(s,t)$ such that type $s$ is a
subtype of type $t$.

\item
$\HT : \Hdom \times \Tdom$

Relation containing each tuple $(h,t)$ such that object allocation
statement $h$ allocates objects of type $t$.

\item
$\VT : \Vdom \times \Tdom$

Relation containing each tuple $(v,t)$ such that local variable $v$
has type $t$.

\item
$\MH : \Mdom \times \Hdom$

Relation containing each tuple $(m,h)$ such that method $m$ contains
object allocation statement $h$.

\item
$\MI : \Mdom \times \Idom$

Relation containing each tuple $(m,i)$ such that method $m$ contains
method invocation statement $i$.

\item
$\ME : \Mdom \times \Edom$

Relation containing each tuple $(m,e)$ such that method $m$ contains
statement $e$ that accesses (reads or writes) an instance field, a
static field, or an array element.

\item
$\instM : \Mdom$

Relation containing all instance (as opposed static) methods.

\item
$\statM : \Mdom$

Relation containing all static (as opposed instance) methods.

\item
$\clinitM : \Mdom$

Relation containing all class initializer methods, namely,
methods having signature {\tt void <clinit>()}.

\item
$\IinvkArg : \Idom \times \Zdom \times \Vdom$

Relation containing each tuple $(i,z,v)$ such that local variable $v$
is the $z^{th}$ argument variable of method invocation statement $i$.

\item
$\IinvkRet : \Idom \times \Zdom \times \Vdom$

Relation containing each tuple $(i,z,v)$ such that local variable $v$
is the $z^{th}$ return variable of method invocation statement $i$.

\item
$\MmethArg : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable
$v$ is the $z^{th}$ argument variable of method $m$.

\item
$\MmethRet : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable
$v$ is the $z^{th}$ return variable of method $m$.

\item
$\MspcMethArg : \Mdom \times \Vdom$

Relation containing each tuple $(m,v)$ such that local variable $v$ is
the implicit {\tt this} argument variable of instance method $m$.

\item

$\MordMethArg : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable $v$
is the $z^{th}$ argument variable of method $m$ other than the implicit
{\tt this} argument variable (in the case in which $m$ is an instance
method).

\item
$\MobjVarAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,r)$ such that method $m$
contains a copy statement of the form $l = r$ where $l$ and $r$ are
local variables.

\item
$\MobjValAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,h)$ such that method $m$ contains
object allocation statement $h$ which assigns to local variable $l$.

\item
$\MclsVarAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,b)$ such that method $m$
contains a statement of the form $l = b.{\tt getClass()}$.

\item
$\MgetInstFldInst : \Mdom \times \Vdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,b,f,r)$ such that method $m$
contains a statement of the form $b.f = r$ which assigns to
instance field or array element $f$ of the object denoted by local
variable $b$ the value denoted by local variable $r$.

\item
$\MputInstFldInst : \Mdom \times \Vdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,b,f,r)$ such that method $m$
contains a statement of the form $b.f = r$ which writes the value
denoted by local variable $r$ to instance field or array element
$f$ of the object denoted by local variable $b$.

\item
$\MgetStatFldInst : \Mdom \times \Vdom \times \Fdom$

Relation containing each tuple $(m,l,f)$ such that method $m$ contains
a statement of the form $l = f$ that assigns to local variable $l$ the
value denoted by static field $f$.

\item
$\MputStatFldInst : \Mdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,f,r)$ such that method $m$ contains
a statement of the form $f = r$ which assigns to static field $f$ the
value denoted by local variable $r$.

\item
$\virtIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokevirtual} or {\tt invokeinterface} method
invocation statement $i$.

\item
$\statIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokestatic} method invocation statement $i$.

\item
$\specIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokespecial} method invocation statement $i$.

\item
$\syncMV : \Mdom \times \Vdom$

Relation containing each tuple $(m,v)$ such that method $m$ is
synchronized on argument variable $v$.

\item
$\writeE : \Edom$

Relation containing all statements that write (as opposed to read)
an instance field, static field, or array element.

\item
$\EF : \Edom \times \Fdom$

Relation containing each tuple $(e,f)$ such that statement $e$
accesses (reads or writes) instance field, static field, or
array element $f$.

\item
$\VH : \Vdom \times \Hdom$

Relation containing each tuple $(v,h)$ such that local variable $v$
may point to abstract object $h$, as determined by 0CFA-based may
alias analysis.

\item
$\FH : \Fdom \times \Hdom$

Relation containing each tuple $(f,h)$ such that static field $f$ may
point to abstract object $h$, as determined by 0CFA-based may alias
analysis.

\item

$\HFH : \Hdom \times \Fdom \times \Hdom$

Relation containing each tuple $(h_1,f,h_2)$ such that instance field
or array element $f$ of abstract object $h_1$ may point to abstract
object $h_2$, as determined by 0CFA-based may alias analysis.

\item
$\IM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that method invocation
statement $i$ may call method $m$ as determined by 0CFA-based may alias
analysis.

\item
$\nestedLocks : \Cdom \times \Cdom \times \Mdom \times \Cdom \times \Mdom$

Relation containing each tuple $(c,c_1,m_1,c_2,m_2)$ such that in the
context-sensitive call graph computed by k-object-sensitive may
alias analysis, abstract thread $c$ may first acquire the lock at
the entry of method $m_1$ in abstract context $c_1$ and without
releasing it proceed to acquire the lock at the entry of method
$m_2$ in abstract context $c_2$.

\item
$\forkC : \Cdom$

Relation containing all abstract contexts in which the
{\tt start()} method of class {\tt java.lang.Thread} may
be reachable from the main method, as determined by
k-object-sensitive may alias analysis.

\item
$\CVC : \Cdom \times \Vdom \times \Cdom$

Relation containing each tuple $(c_1,v,c_2)$ such that local variable
$v$ may point to abstract object $c_2$ in abstract context $c_1$ of its
containing method, as determined by k-object-sensitive may alias
analysis.

\item
$\FC : \Fdom \times \Cdom$

Relation containing each tuple $(f,c)$ such that static field $f$
may point to abstract object $c$, as determined by k-object-sensitive
may alias analysis.

\item
$\CFC : \Cdom \times \Fdom \times \Cdom$

Relation containing each tuple $(c_1,f,c_2)$ such that instance field
or array element $f$ of abstract object $c_1$ may point to abstract
object $c_2$, as determined by k-object-sensitive may alias analysis.

\item
$\CICM : \Cdom \times \Idom \times \Cdom \times \Mdom$

Relation containing each tuple $(c_1,i,c_2,m)$ such that method
invocation statement $i$ in abstract context $c_1$ of its containing method
may call method $m$ in abstract context $c_2$, as determined by
k-object-sensitive may alias analysis.

\item
$\CHC : \Cdom \times \Hdom \times \Cdom$

Relation containing each tuple $(c_1,h,c_2)$ such that the method
containing object allocation statement $h$ may be reachable in
abstract context $c_1$, and $c_2 = (h::c_1) + k$, where $k$ is the k
value of statement $h$, provided as an argument to k-object-sensitive
may alias analysis.

\end{itemize}

\texonly{\newpage}
\section{Pre-defined Datalog-based Analyses}
\label{sec-predef-datalog-analyses}

\texonly{\newpage}
\section{Pre-defined Java-based Analyses}
\label{sec-predef-java-analyses}

\texonly{\newpage}
\bibliographystyle{plain}
\bibliography{citations}

\end{document}

\newpage
\section{Defining Tasks and Targets}

\Chord\ uses the notion of {\it tasks} to express computations
and the notion of {\it targets} to express the structure of
inputs/outputs of computations.

Tasks and targets are both implemented uniformly as {\it entities}.
A generic entity is represented by class {\tt chord.Entity}
depicted in Figure \ref{fig-entity}.

\begin{figure}
\begin{verbatim}
public class Entity {
    protected static final String[] emptyStringArray = new String[0];
    // subclasses may override
    public void execute() {
        // do nothing
    }
    // subclasses may override
    public String[] getConsumedTargetNames() {
        return emptyStringArray;
    }
    // subclasses may override
    public String[] getProducedTargetNames() {
        return emptyStringArray;
    }
    ...
}
\end{verbatim}
\caption{Snippet of class {\tt chord.Entity}}
\label{fig-entity}
\end{figure}

Whenever an enntity is regarded as a task:

\begin{itemize}
\item
The {\tt execute} method defines the computation that must be performed by the task.

\item
The {\tt getConsumedTargetNames} method specifies the names of targets
that are inputs to (the computation performed by) the task.

\item
The {\tt getProducedTargetNames} method specifies the names of targets
that are outputs of (the computation performed by) the task.
\end{itemize}

There are four kinds of entities:
\begin{itemize}
\item
A program domain

\item
A program relation

\item
A program analysis expressed in Datalog

\item
A program analysis expressed in Java

\end{itemize}

We next describe each of these kinds of entities in detail.

\subsection{Program Domains}

A program domain is a set of related elements in a given program (e.g.,
the set of all methods, the set of all object allocation statements, etc.).
The structure of a generic program domain is represented by
class {\tt chord.Dom} depicted in Figure \ref{fig-dom}.

\begin{figure}
\begin{verbatim}
public class Dom<T> extends Entity {
    public final IndexMap<T> map;
    public Dom() {
        this.map = new IndexMap<T>();
    }
    public void execute() {
        populate();
        saveToDomFile();
    }
    // subclasses cannot override
    public final String[] getProducedTargetNames() {
        return emptyStringArray;
    }
    // subclasses may override
    protected void populate() {
        // do nothing
    }
    ...
\end{verbatim}
\caption{Snippet of class {\tt chord.Dom}}
\label{fig-dom}
\end{figure}

A program domain provides a map from each element in the domain
to a unique integer in the range $[0..n-1]$ where $n$ is the size of
the domain.
This map is required by {\tt bddbddb} (a BDD-based Datalog solver).
The {\tt execute} method is specialized to construct the map and then
save the map to disk for use by {\tt bddbddb}.
Subclasses must override the {\tt populate} method to construct the
map as desired.

It is not possible to override the {\tt getProducedTargetNames}
method (note that it is declared {\tt final}) because a program domain
task is a specialized task whose output is exactly one target, namely,
the program domain it constructs.
It is, however, possible to override the {\tt getConsumedTargetNames}
method (inherited from superclass {\tt chord.Entity}) since constructing
a program domain may require other targets (i.e., other program
domains, program relations, or program analyses).

Figure \ref{fig-domI} defines the program domain
named $\Idom$ as the domain of all method invocation statements.
Note from method {\tt getConsumedTargetNames} that it takes as input
the domain named $\Mdom$ which is the domain of all methods.
This is because the {\tt populate} method refers to that domain.
Intuitively, the {\tt populate} method gives adjacent indices in
domain $\Idom$ to method invocation statements contained in
methods that have adjacent indices in domain $\Mdom$ are given
adjacent indices in domain $\Idom$.

\begin{figure}
\begin{verbatim}
public class DomI extends Dom<InvkInst> {
    private IndexMap<Method> mapM;
    private final String[] consumedTaskNames = new String[] { "M" };
    public String[] getConsumedTargetNames() {
        return consumedTaskNames;
    }
    protected void populate() {
        DomM domM = (DomM) project.getEntity("M");
        mapM = domM.map;
        for (int m = 0; m < mapM.size(); m++) {
            Method meth = mapM.get(m);
            Body body = meth.body;
            if (body == null)
                continue;
            Set<Inst> insts = body.cfg.getNodes();
            for (Inst inst : insts) {
                if (inst instanceof InvkInst)
                    map.set((InvkInst) inst);
            }
        }
    }
    ...
}
\end{verbatim}
\caption{Snippet of class {\tt chord.DomI}}
\label{fig-domI}
\end{figure}

A list of pre-defined program domains is presented in Section \ref{sec-predef-domains}.

\subsection{Program Relations}

A program relation is a relation over one or more program domains.
The structure of a generic program relation is represented by class
{\tt chord.Rel} depicted in Figure \ref{fig-rel}.

\begin{figure}
\begin{verbatim}
\end{verbatim}
\caption{Snippet of class {\tt chord.Rel}}
\label{fig-rel}
\end{figure}

It is not possible to override the {\tt getProducedTargetNames}
method (note that it is declared {\tt final}) because a program relation
task is a specialized task whose output is exactly one target, namely,
the program relation it constructs.
It is, however, possible to override the {\tt getConsumedTargetNames}
method (inherited from superclass {\tt chord.Entity}) since constructing
a program relation may require other targets (i.e., program
domains, other program relations, or program analyses).

A list of pre-defined program relations is presented in Section \ref{sec-predef-relations}.

\subsection{Program Analyses in Datalog}

A list of pre-defined program analyses in Datalog is presented in
Section \ref{sec-predef-datalog-analyses}.

\subsection{Program Analyses in Java}

A list of pre-defined program analyses in Java is presented in
Section \ref{sec-predef-java-analyses}.
