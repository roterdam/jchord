# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# k-CFA may-alias analysis.
# Assume call graph construction is fixed.

# Author: Mayur Naik (mhn@cs.stanford.edu), Percy Liang (pliang@cs.berkeley.edu)
# name=cspa-kcfa-sliver-dlog

.include "F.dom"
.include "H.dom"
.include "I.dom"
.include "M.dom"
.include "T.dom"
.include "V.dom"
.include "Z.dom"
.include "C.dom"

.bddvarorder F0_I0xI1xM0xM1_T0_V0xV1_T1_H0_C0xC1xC2_Z0

###
# Relations
###

HT(h:H0,t:T1) input
sub(t1:T1,t2:T0) input
MI(m:M,i:I) input
MH(m:M,h:H) input

# Program statements
MobjValAsgnInst(m:M,l:V,h:H) input
MobjVarAsgnInst(m:M,l:V,r:V) input
MgetInstFldInst(m:M,l:V,b:V,f:F) input
MputInstFldInst(m:M,b:V,f:F,r:V) input
MgetStatFldInst(m:M,l:V,f:F) input
MputStatFldInst(m:M,f:F,r:V) input

# Filtered by reachability
RobjValAsgnInst(c:C,l:V,h:H) output
RobjVarAsgnInst(c:C,l:V,r:V) output
RgetInstFldInst(c:C,l:V,b:V,f:F) output
RputInstFldInst(c:C,b:V,f:F,r:V) output
RgetStatFldInst(c:C,l:V,f:F) output
RputStatFldInst(c:C,f:F,r:V) output

classT(t:T) input
staticTM(t:T,m:M) input
staticTF(t:T,f:F) input
clinitTM(t:T,m:M) input
IinvkArg(i:I0,n:Z0,v:V1) input
MmethArg(m:M0,n:Z0,v:V0) input
IinvkRet(i:I0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
argCopy(i:I0,u:V1,m:M0,v:V0) output
retCopy(i:I0,u:V0,m:M0,v:V1) output
VCfilter(v:V,c:C) input

CC(c:C,d:C) input # d = [* c]
CH(c:C,h:H) input # c = [h ...]
CI(c:C,i:I) input # c = [i ...]
#equivC(c:C,d:C) input # c and d are the same (but we didn't collapse them - just for correctness testing)

# Computed from 0-CFA: we don't want the call graph changing on us during refinement.
IM(i:I,m:M) input # call site i can resolve to method m
reachableM(m:M) input # method is reachable
reachableT(t:T) # type is reachable

CVCV(c:C0,u:V0,d:C1,v:V1) output # u in context c (method) ~ v in context d (call site)

reachableCI(c:C,i:I) output
reachableCM(c:C,m:M) output

CICM(c:C,i:I,d:C,m:M) output # in context c, call site i can call method m in context d

CVC(c:C,v:V,o:C) output   # in context c, variable v can point to abstract object o
FC(f:F,c:C) output        # static field f can point to abstract object c
CFC(c1:C,f:F,c2:C) output # abstract object c1 can point to abstract object c2 via field f

extCIC(c:C,i:I,d:C) output # extend: d = [i, c]
extCHC(c:C,h:H,d:C) output # extend: d = [h, c]

ItoH(i:I,h:H) output # i can call a method that contains h
ItoI(i:I,j:I) output # i can call a method that contains j
reachableH(h:H) output

rM(m:M) output
rI(i:I) output

############################################################
# Constraints

### Extension of contexts

extCIC(c,i,d) :- CC(c,d), CI(d,i). # extend: d = [i, c]
extCHC(c,h,d) :- CC(c,d), CH(d,h). # extend: d = [h, c]

# Call site i in context c resolves to method m in context d
CICM(c,i,d,m) :- reachableCI(c,i), IM(i,m), extCIC(c,i,d).

### Reachability

# Reachability of methods.
reachableCM(0,0). # Main method
reachableCM(0,m) :- clinitTM(t,m), reachableT(t). # Any class initializers
reachableCM(c,m) :- CICM(_,_,c,m). # If reachable in any context

# Reachability of call sites.
reachableCI(c,i) :- MI(m,i), reachableCM(c,m).

# Reachability of types
reachableT(t) :- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
reachableT(t) :- reachableCM(_,m), staticTM(t,m).
reachableT(t) :- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
reachableT(t) :- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
reachableT(t) :- classT(t), reachableT(s), sub(s,t).

### Inter-procedural (connect variables)

argCopy(i,u,m,v) :- IM(i,m), IinvkArg(i,z,u), MmethArg(m,z,v). # u at call site i <=> v in method m (argument)
retCopy(i,u,m,v) :- IM(i,m), IinvkRet(i,z,u), MmethRet(m,z,v). # u at call site i <=> v in method m (return value)

CVCV(d,v,c,u) :- argCopy(i,u,m,v), CICM(c,i,d,m). # v in context d <== u in context c
CVCV(c,u,d,v) :- retCopy(i,u,m,v), CICM(c,i,d,m). # u in context c <== v in context d

CVC(c,u,o) :- CVCV(c,u,d,v), CVC(d,v,o), VCfilter(u,o). # If d:v->o, then c:u->o

### Intra-procedural statements

# in context c, l = new h
RobjValAsgnInst(c,l,h) :- reachableCM(c,m), MobjValAsgnInst(m,l,h).
CVC(c,l,o) :- RobjValAsgnInst(c,l,h), extCHC(c,h,o), VCfilter(l,o).

# in context c, l = r
RobjVarAsgnInst(c,l,r) :- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
CVC(c,l,c1) :- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).

# in context c, l = b.f
RgetInstFldInst(c,l,b,f) :- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
CVC(c,l,c2) :- RgetInstFldInst(c,l,b,f), CVC(c,b,c1), CFC(c1,f,c2). split

# in context c, l = STATIC.f
RgetStatFldInst(c,l,f) :- reachableCM(c,m), MgetStatFldInst(m,l,f).
CVC(c,l,o) :- RgetStatFldInst(c,l,f), FC(f,o), VCfilter(l,o).

# in context c, b.f = r
RputInstFldInst(c,b,f,r) :- reachableCM(c,m), MputInstFldInst(m,b,f,r).
CFC(c1,f,c2) :- RputInstFldInst(c,b,f,r), CVC(c,b,c1), CVC(c,r,c2). split

# in context c, STATIC.f = r
RputStatFldInst(c,f,r) :- reachableCM(c,m), MputStatFldInst(m,f,r).
FC(f,o) :- RputStatFldInst(c,f,r), CVC(c,r,o).

# Possible extensions based on fixed call graph.
ItoH(i,h) :- IM(i,m), MH(m,h).
ItoI(i,j) :- IM(i,m), MI(m,j).
reachableH(h) :- reachableM(m), MH(m,h).

# TMP
#CFC(c1,f,c2) :- CFC(d1,f,c2), equivC(c1, d1).
#CFC(c1,f,c2) :- CFC(c1,f,d2), equivC(c2, d2).
#CVC(c,f,o) :- CVC(c,f,p), equivC(o,p).
rM(m) :- reachableCM(_, m).
rI(i) :- reachableCI(_, i).
