# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Runs 0-CFA and initializes everything.

# Author: Percy Liang (pliang@cs.berkeley.edu)
# name=cspa-init-sliver-dlog

.include "F.dom"
.include "H.dom"
.include "E.dom"
.include "I.dom"
.include "M.dom"
.include "T.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder F0_I0xI1xM0xM1_T0_V0xV1_T1_H0xH1_Z0_E0

############################################################
# Relations

# Static program inputs.
MI(m:M,i:I) input # Method m contains call site i
MH(m:M,h:H) input # Method m contains allocation site h
MV(m:M,v:V) input # Method m contains variable v
TM(t:T,m:M) input
ME(m:M,e:E) input
EV(e:E,v:V) input
statIM(i:I,m:M) input # Call site i resolves to static method m
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
MmethArg(m:M0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input
checkExcludedT(t:T) input

# Computed from 0-CFA.
IM(i:I,m:M) input # call site i can resolve to method m
VH(v:V,h:H) input # Whether variable v can point to an object allocated at h
reachableM(m:M) input # method m is reachable

# Output one-time relations.
queryE(e:E) output # Which queries we want to answer
reachableH(h:H) output # allocation site h is reachable
reachableV(v:V) output # variable v is reachable
argCopy(i:I0,u:V1,m:M0,v:V0) output # vi at call site i <=> vm in method m (argument)
retCopy(i:I0,u:V0,m:M0,v:V1) output # vi at call site i <=> vm in method m (return value)
IthisH(i:I,h:H) output # at call site i, this argument can point to something in h
skipMM(m:M,n:M) output # m can reach n via a sequence of calls where m is instance method, rest (if any) are static methods
HtoM(h:H,m:M) output # h can be the "this" argument calling method that skips to m

queryE(e) :- !checkExcludedT(t), TM(t,m), ME(m,e), EV(e,_). # All queries we care about
reachableH(h) :- reachableM(m), MH(m,h).
reachableV(v) :- reachableM(m), MV(m,v).
argCopy(i,vi,m,vm) :- IM(i,m), IinvkArg(i,z,vi), MmethArg(m,z,vm).
retCopy(i,vi,m,vm) :- IM(i,m), IinvkRet(i,z,vi), MmethRet(m,z,vm).

# For object-based refinement
IthisH(i,h) :- !statIM(i,_), IinvkArg(i,0,v), VH(v, h), reachableH(h).
skipMM(m,n) :- m=n, !statIM(_,m).
skipMM(m,n) :- skipMM(m,q), MI(q,i), statIM(i,n). # Can extend q to n using static method
HtoM(h,n) :- IinvkArg(i,0,v), VH(v,h), IM(i,m), skipMM(m,n).
