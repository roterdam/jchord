# Copyright (c) 2008-2010, Intel Corporation.
# Copyright (c) 2006-2007, The Trustees of Stanford University.
# All rights reserved.
# Licensed under the terms of the New BSD License.

# Runs 0-CFA and initializes everything.

# Author: Percy Liang (pliang@cs.berkeley.edu)
# name=cspa-init-sliver-dlog

.include "F.dom"
.include "H.dom"
.include "I.dom"
.include "M.dom"
.include "T.dom"
.include "V.dom"
.include "Z.dom"

.bddvarorder F0_I0xI1xM0xM1_T0_V0xV1_T1_H0xH1_Z0

############################################################
# Relations

# Static program inputs.
MI(m:M,i:I) input # Method m contains call site i
MH(m:M,h:H) input # Method m contains allocation site h
MV(m:M,v:V) input # Method m contains variable v
statIM(i:I,m:M) input # Call site i resolves to static method m
IinvkArg(i:I0,n:Z0,v:V1) input
IinvkRet(i:I0,n:Z0,v:V0) input
MmethArg(m:M0,n:Z0,v:V0) input
MmethRet(m:M0,n:Z0,v:V1) input

# Computed from 0-CFA.
IM(i:I,m:M) input # call site i can resolve to method m
VH(v:V,h:H) input # Whether variable v can point to an object allocated at h
reachableM(m:M) input # method m is reachable

# Output one-time relations.
IthisH(i:I,h:H) output # at call site i, this argument can point to something in h
ItoI(i:I,j:I) output # i can call a method that contains j
HtoH(g:H,h:H) output # # g can be the "this" argument, calling method containing h
skipMM(m:M,n:M) output # for object-based: if analyze m in some context, will analyze n in the same context
reachableH(h:H) output # allocation site h is reachable
reachableV(v:V) output # variable v is reachable
argCopy(i:I0,u:V1,m:M0,v:V0) output # vi at call site i <=> vm in method m (argument)
retCopy(i:I0,u:V0,m:M0,v:V1) output # vi at call site i <=> vm in method m (return value)

############################################################
# Constraints

reachableH(h) :- reachableM(m), MH(m,h).
reachableV(v) :- reachableM(m), MV(m,v).

argCopy(i,vi,m,vm) :- IM(i,m), IinvkArg(i,z,vi), MmethArg(m,z,vm).
retCopy(i,vi,m,vm) :- IM(i,m), IinvkRet(i,z,vi), MmethRet(m,z,vm).

IthisH(i,h) :- IinvkArg(i,0,v), VH(v, h).

# For call-site-based refinement
ItoI(i,j) :- IM(i,m), MI(m,j).

# For object-based refinement
HtoH(g,h) :- IinvkArg(i,0,v), VH(v,g), IM(i,m), skipMM(m,n), MH(n,h).
skipMM(m,n) :- m=n.
skipMM(m,n) :- MI(m,i), statIM(i,n). # Idea: if analyze m in some context, we end up analyzing n in that context as well
