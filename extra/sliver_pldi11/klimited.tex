\Section{klimited}{$k$-limited Pointer Analysis}

% Basics
We now introduce our $k$-limited pointer analysis,
on which we will apply the Prune-Refine algorithm.
Each node in the control-flow graph of each method $m \in \M$ is associated with a
simple statement (e.g., $v_2 = v_1$).
We omit statements that have no effect on our analysis (e.g., operations on
data of primitive type).
For simplicity, we assume each method has a single argument and no return value.\footnote{
Our actual implementation is a straightforward extension of this simplified analysis
which handles multiple arguments, return values, class initializers, and
objects allocated through reflection.}
\reffig{aliasAnalysisRules} describes the Datalog program corresponding to this
analysis.

% Context, abstraction
The analysis represents both contexts and abstract objects using chains of
allocation sites ($\C = \H^*$).  Contexts are extended into new contexts via the $\ext$ relation,
which prepends an allocation site to a chain (e.g., $\ext(3,[12],[312])$).
Note that these chains are not truncated in the Datalog program, and therefore,
running the Datalog program directly (ignoring the fact that it might not
terminate) corresponds to performing an $\infty$-object-sensitivity analysis.

Although this Datalog program itself is an approximation to the concrete
program semantics---it is flow-insensitive, does not handle primitive data,
etc., we will informally say that a client query computed with respect to this
analysis yields a concrete answer.  In contrast, we obtain an abstract
answer by computing the client query with respect to a $k$-limited abstraction,
which we will discuss in \refsec{generalRelationship}.

% Rules
We now briefly describe the Datalog rules in \reffig{aliasAnalysisRules}.  Rule (1)
states that the main method $\mmain$ is reachable in a distinguished context $[\,]$.
Rule (2) states that a target method of a reachable call site is also reachable.
Rule (3) states that every statement in a reachable method is also reachable.
Rules (4) through (9) implement the transfer function associated with each kind of statement.
Rule (10) analyzes the target method
$m$ in a separate context $o$ for each abstract object $o$ to which the distinguished
{\tt this} argument of method $m$ points, and rule (11) sets the points-to set
of the {\tt this} argument of method $m$ in context $o$ to the singleton $\{ o \}$.

Our analysis computes the reachable methods ($\reachM$), reachable statements ($\reachP$), and
points-to sets of local variables ($\ptsV$), each with the associated context;
the context-insensitive points-to sets of static fields ($\ptsG$) and
heap graph ($\heap$); and a context-sensitive call graph ($\cg$).

\begin{figure*}
\begin{minipage}{3.3in}
{\bf Domains}: \\
\[
\begin{array}{rrcl}
\mbox{{(method)}}                  & m   &\in & \M = \{ \mmain, ... \}\\
\mbox{{(local variable)}}          & v   &\in & \V \\
\mbox{{(global variable)}}         & g   &\in & \G  \\
\mbox{{(object field)}}            & f   &\in & \F  \\
\mbox{{(method call site)}}        & i   &\in & \I \\
\mbox{{(allocation site)}}         & h   &\in & \H \\
\mbox{{(statement)}}               & p   &\in & \P \\
\mbox{{(method context)}}          & c   &\in& \C = \H^* \\
\mbox{{(abstract object)}}         & o   &\in& \O = \H^* \\
\end{array}
\]
\[
\begin{array}{ll}
p ::= & v = \new\,h \bigmid v_2 = v_1 \bigmid g = v \bigmid v = g \bigmid \\
      & v_2.f = v_1 \bigmid v_2 = v_1.f  \bigmid i(v)
\end{array}
\]
\end{minipage}
\begin{minipage}{3.7in}
{\bf Input relations}: \\
\[ \begin{array}{lcll}
\body     &\subset& \M \times \P & \text{(method contains statement)} \\
\trgt     &\subset& \I \times \M & \text{(call site resolves to method)} \\
\argI     &\subset& \I \times \V & \text{(call site's argument variable)} \\
\argM     &\subset& \M \times \V & \text{(method's formal argument variable)} \\
\ext      &\subset& \H \times \C \times \C & \text{(extend context with site)} \\
          & =     & \multicolumn{2}{l}{\{ (h, c, [h]+c) : h\in\H, c\in\C \}} \\
\end{array}
\]
{\bf Output relations}: \\
\[ \begin{array}{lcll}
\reachM   &\subset& \C \times \M & \text{(reachable methods)} \\
\reachP   &\subset& \C \times \P & \text{(reachable statements)} \\
\ptsV     &\subset& \C \times \V \times \O & \text{(points-to sets of local variables)} \\
\ptsG     &\subset& \G \times \O & \text{(points-to sets of static fields)} \\
\heap     &\subset& \O \times \F \times \O & \text{(heap graph)} \\
\cg       &\subset& \C \times \I \times \C \times \M & \text{(call graph)}
\end{array}
\]
\end{minipage}
{\bf Rules}: \\
\[
\begin{array}{lclr}
\reachM([],\mmain). &           &  & (1) \\
\reachM(c,m)              &\dlogUpdate& \cg(*,*,c,m). & (2) \\
\reachP(c,p)              &\dlogUpdate& \reachM(c,m),\ \body(m,p). & (3)
\\[8pt]
\ptsV(c,v,o)              &\dlogUpdate& \reachP(c, v = \new\,h),\ \ext(h, c, o). & (4) \\
\ptsV(c,v_2,o)            &\dlogUpdate& \reachP(c, v_2 = v_1),\ \ptsV(c,v_1,o). & (5) \\
\ptsG(g,o)                &\dlogUpdate& \reachP(c, g = v),\ \ptsV(c,v,o). & (6) \\
\ptsV(c,v,o)              &\dlogUpdate& \reachP(c, v = g),\ \ptsG(g,o). & (7) \\
\heap(o_2,f,o_1)          &\dlogUpdate& \reachP(c, v_2.f = v_1),\ \ptsV(c,v_1,o_1),\ \ptsV(c,v_2,o_2). & (8) \\
\ptsV(c,v_2,o_2)          &\dlogUpdate& \reachP(c, v_2 = v_1.f),\ \ptsV(c,v_1,o_1),\ \heap(o_1,f,o_2). & (9)
\\[8pt]
\cg(c,i,o,m)            &\dlogUpdate& \reachP(c,i),\ \trgt(i,m),\ \argI(i,v),\ \ptsV(c,v,o). & (10) \\
\ptsV(c,v,c)             &\dlogUpdate& \reachM(c,m),\ \argM(m,v). & (11)
\end{array}
\]
%\centering
\caption{Datalog implementation of our $k$-object-sensitivity points-to analysis with call-graph construction.
Our abstraction $\ba$ affects the analysis solely through $\ext$,
which specifies that when we prepend $s$ to $c$, we truncate the resulting sequence to length $\ba_{s}$.
}
\label{fig:aliasAnalysisRules}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Subsection{clients}{Clients}

The core pointer analysis just described is used by three clients, which each
define a set of queries.

\paragraph{Monomorphic call site detection}

Monomorphic call sites are dynamically dispatched call sites with at most one
target method.  These can be transformed into statically dispatched ones which
are cheaper to execute.
For each call site $i \in \I$ whose target is a virtual method,
we create a query $\dl{poly}(i)$ asking whether $i$ is polymorphic.
This query can be computed with the following rule:
\begin{align}
\dl{poly}(i) \dlogUpdate \cg(*,i,*,m_1), \cg(*,i,*,m_2), m_1 \neq m_2.
\end{align}

\paragraph{Downcast safety checking}

A safe downcast is one that cannot fail because the object to which the
downcast is applied is guaranteed to be a subtype of the target type.
Therefore, safe downcasts obviate the need for run-time cast checking.
We create a query for each downcast---statement of the form $v_1 = v_2$ where the
declared type of $v_2$ is not a subtype of the declared type of $v_1$.
The query can be computed with the following rule:
\begin{align}
& \dl{unsafe}(v_1,v_2) \dlogUpdate \ptsV(*,v_2,o), \dl{typeO}(o,t_2), \dl{typeV}(v_1,t_1), \nonumber \\
& \hspace{1in} \neg\dl{subtype}(t_1,t_2).
\end{align}
Here, $\dl{typeV}$ is a relation on a variable and its declared type
and $\dl{typeO}$ is a relation on an abstract object and its type
(computed by inspecting the initial allocation site of $o$).

\paragraph{Race detection}

In race detection, each query consists of a pair of heap-accessing statements
of the same field in which at least one statement is a write.  We used the
static race detector of \cite{NaikAikenWhaley2006}, which declares a
$(p_1,p_2)$ pair as racing if both statements may be reachable, may access
thread-escaping data, may point to the same object, and may happen in parallel.
All four components rely heavily on the context- and object-sensitive points-to
analysis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Subsection{generalRelationship}{Relationship to general notation}

% Relate 
We now describe our analysis in \reffig{aliasAnalysisRules} in terms of our general notation presented in \refsec{preliminaries}.
The set of concrete values $\sC$ is the union of all the domains
(e.g.., allocation sites $\H = \{ 1, 2, 3, \dots \}$, abstract objects $\C = \H^*$, etc.).
The input tuples $X$ are specified by the input relations
(e.g., $X = \{ \body(\mmain, x = \new\,3), \ext(3,[12],[312]) \}$).
Each of the three clients defines a set of possible query tuples, for example,
$\xo = \dl{unsafe}(\dl{v4},\dl{v8})$ for downcast safety checking of an assignment $\dl{v4} = \dl{v8}$.

Recall that $\bP(X)$ corresponds to obtaining an answer to a client query with respect to $\infty$-object-sensitivity.
To obtain $k$-object-sensitivity,
we first apply the $k$-limited abstraction $\pi_k$ to the input tuples
and run the Datalog program on these abstract tuples ($\bP(\pi_k(X))$).
Note that only the $\ext$ tuples are affected by the abstraction.
