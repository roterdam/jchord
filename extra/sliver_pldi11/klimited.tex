\Section{klimited}{$k$-limited Pointer Analysis}

% Basics
We now apply our general pruning approach to $k$-limited pointer analysis.
Each node in the control-flow graph of each method $m \in \M$ is associated with a
simple statement (e.g., $v_2 = v_1$).
We omit statements that have no effect on our analysis (e.g., operations on
data of primitive type).
For simplicity, we assume each method has a single argument and no return value.\footnote{
Our actual implementation is a straightforward extension of this simplified analysis
which handles multiple arguments, return values, class initializers, and
objects allocated through reflection.}
\reffig{aliasAnalysisRules} describes the Datalog program corresponding to this
analysis.

% Context, abstraction
Our analysis represents both contexts and abstract objects using a list of
allocation sites, which we will call {\em chains}.  However, note that these
chains are never truncated in the Datalog program.  Therefore, running the
Datalog program (ignoring the fact that it might not terminate) is performing
an $\infty$-object-sensitivity analysis.  Recall that we separate the
computation of the query in Datalog with the abstraction which is applied to
the input tuples (of course, our Datalog program is itself an approximation to
the concrete semantics---it is flow-insensitive, does not handle primitive
data, etc.).  \refsec{abstractions} will describe further abstractions of this
analysis.

Our analysis computes the reachable methods ($\reachM$), reachable statements ($\reachP$), and
points-to sets of local variables ($\ptsV$), each with the associated context;
the context-insensitive points-to sets of static fields ($\ptsG$) and
heap graph ($\heap$); and a context-sensitive call graph ($\cg$).

We briefly describe the analysis rules in Datalog.  Rule (1)
states that the main method $\mmain$ is reachable in a distinguished context $[]$.
Rule (2) states that a target method of a reachable call site is also reachable.
Rule (3) states that every statement in a reachable method is also reachable.
Rules (4) through (9) implement the transfer function associated with each kind of
statement.
%Rule (10) populate the call graph and
%rule (11) propagate the points-to set from the argument
%of a call site to the formal argument of each target method.
Rule (10) analyzes the target method
$m$ in a separate context $o$ for each abstract object $o$ to which the distinguished
{\tt this} argument of method $m$ points, and rule (11) sets the points-to set
of the {\tt this} argument of method $m$ in context $o$ to the singleton $\{ o \}$.

\begin{figure*}
\begin{minipage}{3.3in}
{\bf Domains}: \\
\[
\begin{array}{rrcl}
\mbox{{(method)}}                  & m   &\in & \M = \{ \mmain, ... \}\\
\mbox{{(local variable)}}          & v   &\in & \V \\
\mbox{{(global variable)}}         & g   &\in & \G  \\
\mbox{{(object field)}}            & f   &\in & \F  \\
\mbox{{(method call site)}}        & i   &\in & \I \\
\mbox{{(allocation site)}}         & h   &\in & \H \\
\mbox{{(statement)}}               & p   &\in & \P \\
\mbox{{(method context)}}          & c   &\in& \C = \H^* \\
\mbox{{(abstract object)}}         & o   &\in& \O = \H^* \\
\end{array}
\]
\[
\begin{array}{ll}
p ::= & v = \new\,h \bigmid v_2 = v_1 \bigmid g = v \bigmid v = g \bigmid \\
      & v_2.f = v_1 \bigmid v_2 = v_1.f  \bigmid i(v)
\end{array}
\]
\end{minipage}
\begin{minipage}{3.7in}
{\bf Input relations}: \\
\[ \begin{array}{lcll}
\body     &\subset& \M \times \P & \text{(method contains statement)} \\
\trgt     &\subset& \I \times \M & \text{(call site resolves to method)} \\
\argI     &\subset& \I \times \V & \text{(call site's argument variable)} \\
\argM     &\subset& \M \times \V & \text{(method's formal argument variable)} \\
\ext      &\subset& \S \times \C \times \C & \text{(extend context with site)} \\
          & =     & \multicolumn{2}{l}{\{ (h, c, [h]+c) : h\in\H, c\in\C \}} \\
\end{array}
\]
{\bf Output relations}: \\
\[ \begin{array}{lcll}
\reachM   &\subset& \C \times \M & \text{(reachable methods)} \\
\reachP   &\subset& \C \times \P & \text{(reachable statements)} \\
\ptsV     &\subset& \C \times \V \times \O & \text{(points-to sets of local variables)} \\
\ptsG     &\subset& \G \times \O & \text{(points-to sets of static fields)} \\
\heap     &\subset& \O \times \F \times \O & \text{(heap graph)} \\
\cg       &\subset& \C \times \I \times \C \times \M & \text{(call graph)}
\end{array}
\]
\end{minipage}
{\bf Rules}: \\
\[
\begin{array}{lclr}
\reachM([],\mmain). &           &  & (1) \\
\reachM(c,m)              &\dlogUpdate& \cg(*,*,c,m). & (2) \\
\reachP(c,p)              &\dlogUpdate& \reachM(c,m),\ \body(m,p). & (3)
\\[8pt]
\ptsV(c,v,o)              &\dlogUpdate& \reachP(c, v = \new\,h),\ \ext(h, c, o). & (4) \\
\ptsV(c,v_2,o)            &\dlogUpdate& \reachP(c, v_2 = v_1),\ \ptsV(c,v_1,o). & (5) \\
\ptsG(g,o)                &\dlogUpdate& \reachP(c, g = v),\ \ptsV(c,v,o). & (6) \\
\ptsV(c,v,o)              &\dlogUpdate& \reachP(c, v = g),\ \ptsG(g,o). & (7) \\
\heap(o_2,f,o_1)          &\dlogUpdate& \reachP(c, v_2.f = v_1),\ \ptsV(c,v_1,o_1),\ \ptsV(c,v_2,o_2). & (8) \\
\ptsV(c,v_2,o_2)          &\dlogUpdate& \reachP(c, v_2 = v_1.f),\ \ptsV(c,v_1,o_1),\ \heap(o_1,f,o_2). & (9)
\\[8pt]
\cg(c,i,o,m)            &\dlogUpdate& \reachP(c,i),\ \trgt(i,m),\ \argI(i,v),\ \ptsV(c,v,o). & (10) \\
\ptsV(c,v,c)             &\dlogUpdate& \reachM(c,m),\ \argM(m,v). & (11)
\end{array}
\]
%\centering
\caption{Datalog implementation of our $k$-object-sensitivity points-to analysis with call-graph construction.
Our abstraction $\ba$ affects the analysis solely through $\ext$,
which specifies that when we prepend $s$ to $c$, we truncate the resulting sequence to length $\ba_{s}$.
}
\label{fig:aliasAnalysisRules}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Subsection{clients}{Clients}

The core pointer analysis is used by three clients, which each define a set of queries.

\paragraph{Monomorphic call site detection}

Monomorphic call sites are dynamically dispatched call sites with at most one
target method.  These can be transformed into statically dispatched ones which
are cheaper to execute.
For each call site $i \in \I$ whose target is a virtual method,
we create a query $\dl{poly}(i)$ asking whether $i$ is polymorphic.
This query can be computed with the following rule:
\begin{align}
\dl{poly}(i) \dlogUpdate \cg(*,i,*,m_1), \cg(*,i,*,m_2), m_1 \neq m_2.
\end{align}

\paragraph{Downcast safety checking}

A safe downcast is one that cannot fail because the object to which the
downcast is applied is guaranteed to be a subtype of the target type.
Therefore, safe downcasts obviate the need for run-time cast checking.
We create a query for each downcast---statement of the form $v_1 = v_2$ where the
declared type of $v_2$ is not a subtype of the declared type of $v_1$.
The query can be computed with the following rule:
\begin{align}
& \dl{unsafe}(v_1,v_2) \dlogUpdate \ptsV(*,v_2,o), \dl{typeO}(o,t_2), \dl{typeV}(v_1,t_1), \nonumber \\
& \hspace{1in} \neg\dl{subtype}(t_1,t_2).
\end{align}
Here, $\dl{typeV}$ is a relation on a variable and its declared type
and $\dl{typeO}$ is a relation on an abstract object and its type
(computed by inspecting the initial allocation site of $o$).

\paragraph{Race detection}

In race detection, each query consists of a pair of heap-accessing statements
of the same field in which at least one statement is a write.  We used the
static race detector of \cite{NaikAikenWhaley2006}, which declares a
$(p_1,p_2)$ pair as racing if both statements may be reachable, may access
thread-escaping data, may point to the same object, and may happen in parallel.
All four components rely heavily on the context- and object-sensitive points-to
analysis.
