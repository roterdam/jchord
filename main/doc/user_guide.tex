\documentclass{article}
\usepackage{hyperlatex}

%\topmargin=-0.5in
\texonly{\oddsidemargin=0in}
\texonly{\evensidemargin=0in}
\texonly{\textwidth=5.6in}
%\textheight=8.5in

\htmlmathitalic{0}
\htmltitle{User Guide}
\htmladdress{mayur.naik@gmail.com, \today}

\providecommand\Mdom{{\bf M}}
\providecommand\Idom{{\bf I}}
\providecommand\Vdom{{\bf V}}
\providecommand\Zdom{{\bf Z}}
\providecommand\Hdom{{\bf H}}
\providecommand\Edom{{\bf E}}
\providecommand\Fdom{{\bf F}}
\providecommand\Cdom{{\bf C}}
\providecommand\Tdom{{\bf T}}
\providecommand\Pdom{{\bf P}}

\providecommand\instM{{\bf instM}}
\providecommand\statM{{\bf statM}}
\providecommand\MH{{\bf MH}}
\providecommand\MI{{\bf MI}}
\providecommand\ME{{\bf ME}}

\providecommand\cha{{\bf cha}}
\providecommand\sub{{\bf sub}}
\providecommand\HT{{\bf HT}}
\providecommand\VT{{\bf VT}}
\providecommand\EF{{\bf EF}}
\providecommand\writeE{{\bf writeE}}

\providecommand\virtIM{{\bf virtIM}}
\providecommand\statIM{{\bf statIM}}
\providecommand\specIM{{\bf specIM}}

\providecommand\MmethArg{{\bf MmethArg}}
\providecommand\MmethRet{{\bf MmethRet}}
\providecommand\IinvkArg{{\bf IinvkArg}}
\providecommand\IinvkRet{{\bf IinvkRet}}
\providecommand\MordMethArg{{\bf MordMethArg}}
\providecommand\MspcMethArg{{\bf MspcMethArg}}

\providecommand\MobjVarAsgnInst{{\bf MobjVarAsgnInst}}
\providecommand\MclsVarAsgnInst{{\bf MclsVarAsgnInst}}
\providecommand\MobjValAsgnInst{{\bf MobjValAsgnInst}}
\providecommand\MgetInstFldInst{{\bf MgetInstFldInst}}
\providecommand\MputInstFldInst{{\bf MputInstFldInst}}
\providecommand\MgetStatFldInst{{\bf MgetStatFldInst}}
\providecommand\MputStatFldInst{{\bf MputStatFldInst}}

\providecommand\syncMV{{\bf syncMV}}
\providecommand\nestedLocks{{\bf nestedLocks}}

\providecommand\VH{{\bf VH}}
\providecommand\FH{{\bf FH}}
\providecommand\HFH{{\bf HFH}}
\providecommand\IM{{\bf IM}}

\providecommand\forkC{{\bf forkC}}

\providecommand\CVC{{\bf CVC}}
\providecommand\FC{{\bf FC}}
\providecommand\CFC{{\bf CFC}}
\providecommand\CICM{{\bf CICM}}
\providecommand\CHC{{\bf CHC}}

\providecommand\clinitM{{\bf clinitM}}

\providecommand\Chord{Chord}

\providecommand\NameToTrgtMap{{\tt NameToTrgtMap}}
\providecommand\NameToTaskMap{{\tt NameToTaskMap}}
\providecommand\ConsumedNameToTasksMap{{\tt ConsumedNameToTasksMap}}
\providecommand\TaskGraph{{\tt TaskGraph}}
\providecommand\TaskMapEntries{{\tt TaskMapEntries}}
\providecommand\TrgtMapEntries{{\tt TrgtMapEntries}}
\providecommand\DlogMapEntries{{\tt DlogMapEntries}}
\providecommand\Tasks{{\tt Tasks}}
\providecommand\Trgts{{\tt Trgts}}
\providecommand\ValidTasks{{\tt ValidTasks}}
\providecommand\TrgtNames{{\tt TrgtNames}}

\title{Chord: A Static and Dynamic Program Analysis Framework for Java}
\author{Mayur Naik}
\date{\today}
\begin{document}
\maketitle
\texonly{\tableofcontents}

\texonly{\newpage}
\section{Introduction}

\Chord\ is a static and dynamic program analysis framework for Java.
It has the following key characteristics:

\begin{itemize}
\item
Stand-alone: various off-the-shelf program analyses are provided (e.g., may-alias, thread-escape, datarace, deadlock, etc.).
\item
Extensible: users can build their own program analyses on top of the provided ones.
\item
Compositional: each program analysis can be written independently and yet made to interact in complex ways with other program analyses.
\item
Efficient: results computed by each program analysis are cached for reuse by other program analyses without re-computation.
\item
Flexible: a broad range of program analyses can be expressed, including those
written imperatively in Java or declaratively in Datalog, summary-based as well as cloning-based context-sensitive analyses,
iterative refinement-based analyses, client-driven analyses, and combined static and dynamic analyses.
\end{itemize}

\Chord\ is intended for use by a broad range of users:

\begin{itemize}
\item
Software engineers: Programmers wanting to use program analyses in Chord to assist with software development and testing.
\item
Program analysis appliers: Researchers with possibly a limited program analysis background wanting to build applications on top of program analyses in Chord used as black boxes.
\item
Program analysis writers: Program analysis researchers wanting to implement and evaluate new program analysis algorithms.
\end{itemize}

\Chord\ is intended to work on a variety of platforms, including Linux, Windows/Cygwin, and MacOS.
It has been tested most extensively on Linux.

\Chord\ is open source software distributed under the \xlink{New BSD License}{http://www.opensource.org/licenses/bsd-license.php}.
Contributions from users are welcome and encouraged.

\texonly{\newpage}
\section{Download and Installation}

Ensure that the following software is installed on your machine:

\begin{itemize}
\item
JDK 5 or higher, e.g. from \xlink{IBM}{http://www.ibm.com/developerworks/java/jdk/} or \xlink{Sun}{http://java.sun.com/javase/downloads/index.jsp}
\item
\xlink{Apache Ant}{http://ant.apache.org/}, a Java-based build tool
\item
a C++ compiler, e.g. \xlink{GCC}{http://gcc.gnu.org/}
\item
a Make utility, e.g. \xlink{GNU Make}{http://www.gnu.org/software/make/}
\item
\xlink{Cygwin}{http://www.cygwin.com/}, if it is Windows machine
\end{itemize}

Download the latest \Chord\ version from \xlink{here}{http://code.google.com/p/jchord/downloads/list} and uncompress it.

Directory {\tt chord/main} (henceforth called the main directory) contains a {\tt build.xml} file which is interpreted by Apache Ant.
To see the various targets available, run the following command in that directory:

\begin{quote}
\begin{verbatim}
prompt> ant
\end{verbatim}
\end{quote}

To compile \Chord, run the following command in the same directory:

\begin{quote}
\begin{verbatim}
prompt> ant compile
\end{verbatim}
\end{quote}

This will compile the following:
\begin{itemize}
\item
the Java source code of \Chord\ from {\tt chord/main/src/java/} to Java bytecode in {\tt chord/main/classes/}
\item
the C source code of BDD library \xlink{BuDDy}{http://buddy.sourceforge.net/} from {\tt chord/main/src/bdd/}
to a shared library in {\tt chord/main/lib/} ({\tt libbuddy.so} on Linux, {\tt buddy.dll} on Windows, and {\tt libbuddy.dylib} on MacOS);
this library is needed for executing program analyses written in Datalog using
\xlink{bddbddd}{http://bddbddb.sourceforge.net/} (a BDD-based Datalog solver).
\item
the C++ source code of the Chord instrumentation agent from {\tt chord/main/src/agent/} to a shared
library in {\tt chord/main/lib} ({\tt libchord\_instr\_agent.so} on Linux, {\tt chord\_instr\_agent.dll} on Windows,
and {\tt libchord\_instr\_agent.dylib} on MacOS); this agent is needed for building program scope dynamically
and for executing dynamic program analyses.
\end{itemize}

\texonly{\newpage}
\section{Running Chord}

Suppose the program to be analyzed has the following directory structure:

\begin{quote}
\begin{verbatim}
example/
    src/
        foo/
            Main.java
            ...
    classes/
        foo/
            Main.class
            ...
    lib/
        src/
            taz/
                ...
        jar/
            taz.jar
    chord.properties
\end{verbatim}
\end{quote}

The above structure is typical: the program's Java source files are under \verb+example/src/+,
its class files are under \verb+example/classes/+, the source and jar files of the libraries
used by the program are under \verb+example/lib/src/+ and \verb+example/lib/jar/+, respectively.

File \verb+chord.properties+ specifies properties to be passed to Chord (alternatively,
these properties may be passed on the command-line, in format \verb+-D<name>=<value>+).
A sample such file for the above program is as follows:

\begin{quote}
\begin{verbatim}
chord.main.class=foo.Main
chord.class.path=classes:lib/jar/taz.jar
chord.src.path=src:../lib/src
chord.run.ids=0,1
chord.args.0="-thread 1 -n 10"
chord.args.1="-thread 2 -n 50"
\end{verbatim}
\end{quote}

Each relative (instead of absolute) path element in the value of any property
named \verb+chord.<...>.path+ set in this file is converted to an absolute path element with respect
to the directory containing this file, which in the above case is \verb+example/+.

Section \ref{sec-sys-props} presents an exhaustive
listing of properties recognized by \Chord.
Here, we only describe those set in the above
sample \verb+chord.properties+ file:

\begin{itemize}
\item
\verb+chord.main.class+ specifies the fully-qualified name of the main class of the
program.
\item
\verb+chord.class.path+ specifies the classpath of the program.
The value of pre-defined property \verb+${sun.boot.class.path}+ is implicitly appended
to it.
\item
\verb+chord.src.path+ specifies the Java source path of the program.
All program analyses in Chord operate on Java bytecode (specified by \verb+chord.class.path+).
The only use of this property is to HTMLize the Java source files of the program so that the
results of program analyses can be reported at the Java source code level.
\item
\verb+chord.run.ids+ specifies a list of IDs to identify runs of the program.
It is used by dynamic program analyses to determine how many times the program must be run.
An additional use of this property is to allow specifying the command-line arguments to use
in the run having ID \verb+XXX+ via property \verb+chord.args.XXX+, as illustrated by
properties \verb+chord.args.0+ and \verb+chord.args.1+ in the above example.
\end{itemize}

To run Chord on the above program, run the following command in Chord's main directory:

\begin{quote}
\begin{verbatim}
prompt> ant -Dchord.work.dir=<...>/example run
\end{verbatim}
\end{quote}

where \verb+<...>+ denotes either the absolute path, or the path relative to Chord's main directory,
of the parent of directory {\tt example/}.
System property \verb+chord.work.dir+ specifies the working directory during Chord's execution.

The above command causes Chord to load the \verb+chord.properties+ file if present.
The location of this file may be specified explicitly by property
\verb+chord.props.file+ on the above command line.
By default, it is \verb+${chord.work.dir}/chord.properties+.

In the above case, the above command does not do much beyond loading the sample \verb+chord.properties+ file.
For Chord to do something interesting, you need to set additional properties, either
on the above command line or in the \verb+chord.properties+ file, specifying the task(s)
Chord must perform.
All tasks are summarized in the ``Chord Task Properties" portion of Section \ref{sec-sys-props}.
The two most common tasks, described next, are building program scope (Section \ref{sec:building-scope})
and running program analyses (Section \ref{sec:running-analyses}).

\texonly{\newpage}
\section{Building Program Scope}
\label{sec:building-scope}

Chord computes program scope (i.e. reachable classes and methods of a given Java program) if property
\verb+chord.build.scope+ is set to \verb+true+.
The algorithm used to compute program scope is specified by 
properties \verb+chord.scope.kind+ and \verb+chord.reuse.scope+.

\begin{itemize}
\item
If property \verb+chord.reuse.scope+ is set to \verb+true+ and the files specified by
properties \verb+chord.classes.file+ and \verb+chord.methods.file+ exist,
then Chord regards those files as specifying the classes and methods, respectively,
to be regarded as reachable.  The format
of the classes file is a class name per line (e.g. \verb+foo.Main+).  The format
of the methods file is an entry of the form \verb+<method name>:<method descriptor>@<class name>+ per line,
specifying the method's name, the method's descriptor, and the method's declaring class
(e.g. \verb+main:([Ljava/lang/String;)V@foo.Main+).
Chord throws a runtime exception if the declaring class of a method in the methods file is not
specified in the classes file.
\item
If property \verb+chord.reuse.scope+ is set to \verb+false+ or the file specified by
property \verb+chord.classes.file+ or \verb+chord.methods.file+ does not exist,
then Chord computes program scope
using the algorithm specified by property \verb+chord.scope.kind+ and then
writes the classes and methods deemed reachable by that algorithm to those files.

The possible legal values of property \verb+chord.scope.kind+ are \verb+rta+ and \verb+dynamic+.
In both cases, Chord expects properties \verb+chord.main.class+ and \verb+chord.class.path+
to be set.
\begin{itemize}
\item
The \verb+rta+ value instructs Chord to compute the program scope statically using Rapid Type Analysis.
\item
The \verb+dynamic+ value instructs Chord to compute the program scope dynamically, by running the program
and observing using JVMTI the classes that are loaded at run-time.
The number of times the program is run and the command-line arguments to be supplied to
the program in each run is specified by properties \verb+chord.run.ids+ and
\verb+chord.args.XXX+ for each run ID \verb+XXX+.  By default, the program is run only once, using run ID \verb+0+,
and without any command-line arguments.
Only classes loaded in some run are regarded as reachable but {\it all} methods of each loaded class are regarded
as reachable regardless of whether they were invoked in the run.
The rationale behind this decision is to both reduce run-time overhead of JVMTI and to increase the
predictive power of program analyses performed using the computed program scope.
\end{itemize}
\end{itemize}

The default value of property \verb+chord.reuse.scope+ is \verb+false+ and that of
property \verb+chord.scope.kind+ is \verb+rta+.
The default values of properties \verb+chord.classes.file+ and \verb+chord.methods.file+ are
\verb+${chord.out.dir}/classes.txt+ and \verb+${chord.out.dir}/methods.txt+, respectively,
where property \verb+chord.out.dir+ defaults to \verb+${chord.work.dir}/chord_output/+,
and property \verb+chord.work.dir+ defaults to the current working directory.

\texonly{\newpage}
\section{Running Program Analyses}
\label{sec:running-analyses}

TODO

%chord.run.analyses
%List of names of program analyses to be run in order.
%chord.java.analysis.path	 path	 Classpath containing program analyses in Java (i.e. @Chord-annotated classes).	${chord.main.dir}/classes/
%chord.dlog.analysis.path	 path	 Path of directories containing program analyses in Datalog (i.e. *.datalog and *.dlog files).	${chord.main.dir}/src/main/dlog/
%chord.reuse.rels	 bool	 Construct program relations from BDDs stored on disk (from a previous run of Chord) whenever possible instead of re-computing them.	false
%chord.publish.results	 bool	 Publish the results of program analyses in HTML.	true

\texonly{\newpage}
\section{Chord System Properties}
\label{sec-sys-props}

The following properties are recognized by Chord.
The separator for list-valued properties can be either a blank space, a comma, a colon, or a semi-colon.

\begin{table}[htp]
%\caption{}
\xmlattributes*{table}{border="1"}
\begin{center}
\begin{tabular}{|l|lll|}
\hline
{\bf Property name} & {\bf Type} & {\bf Description} & {\bf Default value (if any)} \\
\hline
\multicolumn{4}{l}{{\bf Chord resource properties}} \\
\verb+chord.main.dir+ & location & \verb+main+ directory in Chord's installation. & \\
\hline
\verb+chord.lib.dir+ & location & Directory containing libraries needed by Chord. & \verb+${chord.main.dir}/lib/+ \\
\hline
\verb+chord.main.class.path+ & path & Classpath of Chord. It includes the path specified by property \verb+chord.java.analysis.path+ to allow running user-defined program analyses. & See \verb+${chord.main.dir}/build.xml+ \\
\hline
\verb+chord.bddbddb.class.path+ & path & Classpath of bddbddb. & See \verb+${chord.main.dir}/build.xml+ \\
\hline
\verb+chord.instr.agent.file+ & location & Shared library implementing Chord instrumentation agent. & \verb+${chord.main.dir}/lib/libchord_instr_agent.so+ (on Linux; \verb+.dll+ on Windows and \verb+.dylib+ on MacOS)\\
\hline
\verb+chord.javadoc.url+ & string & URL of the Javadoc location of program analyses. It is used when publishing targets (i.e. when property \verb+chord.publish.targets+ is set to true). & \verb+http://chord.stanford.edu/javadoc/+ \\
\hline
\multicolumn{4}{l}{{\bf Chord boot properties}} \\
\hline
\verb+chord.work.dir+ & location & Working directory during Chord's execution. & current working directory \\
\hline
\verb+chord.props.file+ & location & Properties file loaded by \verb+${chord.main.dir}/build.xml+.  Any of the below properties, as well as other user-defined properties to be passed to Chord (e.g. for user-defined analyses), may be set in this file.  Each relative (instead of absolute) path element in the value of any property named \verb+chord.<...>.path+ set in this file is converted to an absolute path element with respect to the directory containing this file. & \verb+${chord.work.dir}/chord.properties+ \\
\hline
\verb+chord.max.heap+ & string & Maximum memory size of JVM running Chord. & \verb+1024m+ \\
\hline 
\verb+chord.max.stack+ & string & Maximum thread stack size of JVM running Chord. & \verb+32m+ \\
\hline
\verb+chord.jvmargs+ & string & Arguments passed to JVM running Chord. & \verb+"-showversion -ea -Xmx${chord.max.heap} -Xss${chord.max.stack}"+ \\
\hline
\verb+chord.bddbddb.max.heap+ & string & Maximum memory size of JVM running bddbddb. & \verb+1024m+ \\
\hline
\multicolumn{4}{l}{{\bf Chord task properties}} \\
\hline
\verb+chord.build.scope+ & bool & Compute program scope (i.e. reachable classes and methods) using algorithm specified by properties \verb+chord.scope.kind+ and \verb+chord.reuse.scope+.  Program scope is computed regardless of the value of this property if another task (e.g. a program analysis to be run) needs it. & \verb+false+ \\
\hline
\verb+chord.run.analyses+ & string list & List of names of program analyses to be run in order. & \verb+""+ \\
\hline
\verb+chord.print.rels+ & string list & List of names of program relations whose contents must be printed to files \verb+${chord.out.dir}/<...>.txt+ where \verb+<...>+ denotes the relation name. & \verb+""+ \\
\hline
\verb+chord.publish.targets+ & bool & Publish all targets defined by program analyses in paths specified by properties \verb+chord.java.analysis.path+ and \verb+chord.dlog.analysis.path+. & \verb+false+ \\
\hline
\multicolumn{4}{l}{{\bf Basic program properties}} \\
\hline
\verb+chord.main.class+ & class & Fully-qualified name of main class of given program (e.g. \verb+com.example.Main+). &  \\
\hline
\verb+chord.class.path+ & path & Classpath of given program. \verb+${sun.boot.class.path}+ is implicitly appended to it. & \verb+${sun.boot.class.path}+ \\
\hline
\verb+chord.src.path+ & path & Java source path of given program. & \verb+""+ \\
\hline
\verb+chord.run.ids+ & string list & List of IDs to identify runs of given program. & \verb+0+ \\
\hline
\verb+chord.args.XXX+ & string & Command-line argument string to be used for given program in run having ID \verb+XXX+. & \verb+""+ \\
\hline
\verb+chord.runtime.jvmargs+ & string & Arguments to JVM when running given program.  It is used when the program is executed to compute its scope (i.e. when property \verb+chord.scope.kind+ is set to \verb+dynamic+) as well as when the instrumented program is executed for dynamic analyses. & \verb+"-ea -Xmx1024m"+ \\ 
\hline
\multicolumn{4}{l}{{\bf Program scope properties}} \\ 
\hline
\verb+chord.scope.kind+ & [\verb+rta+|\verb+dynamic+] & Algorithm to compute program scope (i.e. reachable classes and methods).  Current choices include \verb+rta+ (static Rapid Type Analysis) and \verb+dynamic+ (dynamic analysis). & \verb+rta+ \\
\hline
\verb+chord.reuse.scope+ & bool & Treat program scope as the classes and methods listed in files specified by properties \verb+chord.classes.file+ and \verb+chord.methods.file+, respectively. Property \verb+chord.scope.kind+ is ignored if this property is set to \verb+true+ and the two files exist. & \verb+false+ \\
\hline
\verb+chord.check.exclude+ & string list & List of prefixes of names of classes and packages to be excluded by program analyses. Interpretation of this property is analysis-specific. & \verb+"java.,sun.,com.sun.,com.ibm.,org.apache.harmony.,joeq.,jwutil."+ \\
\hline
\verb+chord.instr.exclude+ & string list & List of prefixes of names of classes and packages to be excluded from being instrumented.  Classes in package \verb+java.lang.ref+ are not instrumented regardless of the value of this property. & \verb+"java.,sun.,com.sun.,com.ibm.,org.apache.harmony.,joeq.,jwutil."+ \\
\hline
\multicolumn{4}{l}{{\bf Program analysis properties}} \\
\hline
\verb+chord.java.analysis.path+ & path & Classpath containing program analyses written in Java (i.e. \verb+@Chord+-annotated classes). & \verb+${chord.main.dir}/classes/+ \\
\hline
\verb+chord.dlog.analysis.path+ & path & Path of directories containing program analyses written in Datalog (i.e. \verb+*.datalog+ and \verb+*.dlog+ files). & \verb+${chord.main.dir}/src/dlog/+ \\
\hline
\verb+chord.reuse.rels+ & bool & Construct program relations from BDDs stored on disk (from a previous run of Chord) whenever possible instead of re-computing them. & \verb+false+ \\
\hline
\verb+chord.publish.results+ & bool & Publish the results of program analyses in HTML. Interpretation of this property is analysis-specific. & \verb+true+ \\
\hline
\multicolumn{4}{l}{{\bf Program transformation properties}} \\
\hline
\verb+chord.ssa+ & bool & Do SSA transformation for all methods deemed reachable by the algorithm used to compute program scope. & \verb+true+ \\
\hline
\multicolumn{4}{l}{{\bf Chord debug properties}} \\
\hline
\verb+chord.bddbddb.noisy+ & bool & Make bddbddb output debug info when solving Datalog programs. & \verb+false+ \\
\hline
\verb+chord.save.maps+ & bool & Write to file \verb+${chord.bddbddb.work.dir}/<...>.map+ when saving program domain named \verb+<...>+ (useful for debugging Datalog programs using \verb+debug+ target of \verb+${chord.main.dir}/build.xml+). & \verb+true+ \\
\hline
\multicolumn{4}{l}{{\bf Chord instrumentation properties}} \\
\hline
\verb+chord.trace.pipe+ & bool & Implement the dynamic trace file as a POSIX pipe instead of a regular file. & \verb+true+ \\
\hline
\verb+chord.trace.block.size+ & int & Number of bytes to read/write in a single operation from/to the dynamic trace file. & \verb+4096+ \\
\hline
\verb+chord.runtime.class+ & class & Subclass of \verb+chord.project.Runtime+ used by dynamic program analyses to handle events generated during an instrumented program's execution. & \verb+chord.project.BufferedRuntime+ \\
\hline
\hline
\multicolumn{4}{l}{{\bf Chord output properties}} \\
\hline
\verb+chord.out.dir+ & location & Directory to which Chord dumps all files. & \verb+${chord.work.dir}/chord_output/+ \\
\hline
\verb+chord.out.file+ & location & File to redirect standard output stream during Chord's execution. & \verb+${chord.out.dir}/log.txt+ \\
\hline
\verb+chord.err.file+ & location & File to redirect standard error stream during Chord's execution. & \verb+${chord.out.dir}/log.txt+ \\
\hline
\verb+chord.classes.file+ & location & File from/to which list of classes deemed reachable is read/written. & \verb+${chord.out.dir}/classes.txt+ \\
\hline
\verb+chord.methods.file+ & location & File from/to which list of methods deemed reachable is read/written. & \verb+${chord.out.dir}/methods.txt+ \\
\hline
\verb+chord.bddbddb.work.dir+ & location & Directory used by bddbddb as its input/output directory. & \verb+${chord.out.dir}/bddbddb/+ \\
\hline
\verb+chord.boot.classes.dir+ & location & Directory containing instrumented JDK classes used by given program. & \verb+${chord.out.dir}/boot_classes/+ \\
\hline
\verb+chord.user.classes.dir+ & location & Directory containing instrumented non-JDK classes of given program. & \verb+${chord.out.dir}/user_classes/+  \\
\hline
\verb+chord.instr.scheme.file+ & location & File specifying kind and format of events in dynamic trace file. & \verb+${chord.out.dir}/scheme.ser+ \\
\hline
\verb+chord.crude.trace.file+ & location & Crude dynamic trace file. & \verb+${chord.out.dir}/crude_trace.txt+ \\
\hline
\verb+chord.final.trace.file+ & location & Final dynamic trace file. & \verb+${chord.out.dir}/final_trace.txt+
\end{tabular}
\end{center}
\end{table}

\texonly{\newpage}
\section{Program Representation}

TODO

\texonly{\newpage}
\section{Writing Program Analyses}

TODO

\texonly{\newpage}
\section{Acknowledgments}

Chord would not be possible without the following open-source software:

\begin{itemize}
\item
\xlink{Joeq}{http://joeq.sourceforge.net/}, a Java compiler framework
\item
\xlink{Javassist}{http://www.csg.is.titech.ac.jp/~chiba/javassist/}, a Java bytecode manipulation tool
\item
\xlink{bddbddb}{http://bddbddb.sourceforge.net/}, a BDD-based Datalog solver
\end{itemize}

Chord additionally relies on the following open-source tools and libraries:
\begin{itemize}
\item
\xlink{Ant-Contrib}{http://ant-contrib.sourceforge.net/}, a collection of useful Ant tasks  
\item
\xlink{BuDDy}{http://buddy.sourceforge.net/}, a BDD library
\item
\xlink{GNU Trove}{http://trove4j.sourceforge.net/}, a primitive collections library for Java
\item
\xlink{Java2HTML}{http://www.java2html.com/} and \xlink{Java2Html}{http://www.java2html.de/}, Java to HTML tools
\item
\xlink{Saxon}{http://saxon.sourceforge.net/}, an XSLT processor
\end{itemize}

This user guide was produced using \xlink{Hyperlatex}{http://hyperlatex.sourceforge.net/}.

Chord was supported in part by grants from the National Science Foundation, an equipment grant from Intel, and a Microsoft fellowship during 2005-2007.

\end{document}

\texonly{\newpage}
\section{Program Representation}
\label{sec-prog-build}

Given the program's application classpath via system property {\tt chord.app.class.class}
and either the program's main class via system property {\tt chord.main.class} or
the program's root methods via system property {\tt chord.root.classes}
(and, optionally, system properties {\tt chord.include.root.methods}
and {\tt chord.exclude.root.methods}),
\Chord\ uses system property {\tt chord.program.builder.class} to locate the
builder to be used for building an intermediate representation of the program,
namely, an object of class {\tt chord.program.Program}.
By default, the value of this property is class {\tt chord.program.builders.SootProgramBuilder}
which uses the Soot Java compiler framework \cite{Soot}.
Any builder, however, must implement interface
{\tt chord.program.builders.IProgramBuilder}.

The intermediate representation
elides values of primitive type (e.g., int, boolean, etc.) and operations
on them (e.g., arithmetic and relational operations) in the original program.
The current emphasis of \Chord\ is on the analysis of objects
but the analysis of primitives may be supported in future
releases.

The intermediate representation represents the program as a set of types.
Each type has a set of (instance or static) fields and a set of
(instance or static) methods.
Each method has an optional control-flow graph.
The control-flow graph has a unique entry point and
a unique exit point\footnote{Even the control-flow graph of a method with an infinite loop
has an exit point because loops are transformed into tail-recursive methods
(see Section \ref{sec-prog-transform}).}.
The entry and exit points are always distinct.
Each point in the control-flow graph has one or more immediate predecessors
(except the entry point which has none) and, likewise,
one or more immediate successors (except the exit point which has none).
Associated with each point is a simple statement, which may be of one of
the following kinds:

\begin{itemize}
\item
{\tt HeadInst}

The statement associated with the unique entry point of a control-flow graph.

It serves as a placeholder for:

\begin{itemize}
\item
the (possibly empty) list of the method's {\it argument variables} of reference type;
in the case of an instance method, this list is non-empty,
with the $0^{th}$ element being the distinguished implicit {\tt this}
argument variable.
\item
the (possibly empty) list of the method's {\it temporary variables} of reference type.
\end{itemize}

Argument variables and temporary variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

Argument variables and temporary variables are distinct, namely,
the set of a method's {\it local variables} (of reference type)
is the disjoint union of the sets of the method's argument variables (of reference type) and
temporary variables (of reference type).

\item
{\tt TailInst}

The statement associated with the unique exit point of a control-flow graph.

It serves as a placeholder for 
the (possibly empty) list of the method's {\it return variables} of reference type.

Return variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

The set of a method's return variables (of reference type) is a subset of the set
of the method's local variables (of reference type).

A Java method has at most one return variable but
\Chord's intermediate representation allows multiple return variables
to enable compiling away exceptions, loops, synchronized blocks, etc.

\item
{\tt AcqLockInst}

A statement of the form {\tt monitorenter v} where
{\tt v} is a local variable of reference type.

\item
{\tt RelLockInst}

A statement of the form {\tt monitorexit v} where {\tt v}
is a local variable of reference type.

\item
{\tt StrValAsgnInst}

A statement of the form {\tt v = "..."} where {\tt v} is
a local variable of any reference type that can store a string
constant.  It is typically (but not necessarily) of type
{\tt java.lang.String}.

\item
{\tt NilValAsgnInst}

A statement of the form {\tt v = null} where {\tt v}
is a local variable of reference type.

\item
{\tt StatFldRefInst}

A statement of one of the following forms:

{\tt v = f} \\
{\tt f = v} \\
{\tt * = f} \\
{\tt f = *}

where {\tt v} is a local variable of reference type and
{\tt f} is a static field.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.

\item
{\tt InstFldRefInst}

A statement of one of the following forms:

{\tt v = b.f} \\
{\tt b.f = v} \\
{\tt * = b.f} \\
{\tt b.f = *}

where {\tt v} and {\tt b} are local variables of reference
type and {\tt f} is an instance field.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.

\item
{\tt SkipInst}

A no-op statement.

Due to \Chord's emphasis on the analysis of objects, each statement
in the original program that does not access
any value of reference type (i.e., only accesses values of primitive
type) is represented by this statement.

\item
{\tt InvkInst}

A method invocation statement of the form
{\tt r1,...,rn = m(a1,...,ak)} where
{\tt r1}, ..., {\tt rn} (return variables) and
{\tt a1}, ..., {\tt ak} (argument variables)
are local variables of reference type.

Argument variables and return variables of primitive type are
elided due to \Chord's emphasis on the analysis of objects.

A method invocation statement in Java has at most
one return variable but
\Chord's intermediate representation allows multiple return variables
to enable compiling away exceptions, loops, synchronized blocks, etc.

\item
{\tt ObjVarAsgnInst}

A statement of the form {\tt v1 = v2} where {\tt v1}
and {\tt v2} are local variables of (possibly different) reference types.

\item
{\tt ObjValAsgnInst}

A statement of the form {\tt v = new t} where {\tt t} is a
concrete reference type and
{\tt v} is a local variable of a (possibly different) reference type.

\item
{\tt ClsVarAsgnInst}

A statement of the form {\tt v = b.getClass()} where
{\tt v} is a local variable of type {\tt java.lang.Class}
and {\tt b} is a local variable of reference type.

The reason this kind of statement is modeled is because
\Chord\ has an emphasis on concurrency and many Java programs
hold locks on the runtime class of an object
(which is obtained by calling the native {\tt getClass}
instance method of the object).

\item
{\tt AryElemRefInst}

A statement of one of the following forms:

{\tt v = b[*]}  \\
{\tt b[*] = v} \\
{\tt * = b[*]} \\
{\tt b[*] = *}

where {\tt v} and {\tt b} are local variables of reference
type.

The {\tt *} denotes an expression of primitive type in the
original program which is elided due to \Chord's emphasis on the
analysis of objects.
\end{itemize}

\texonly{\newpage}
\section{Task Graph Construction}
\label{sec-tg}

\Chord\ requires the following three system properties to construct the task graph:

\begin{enumerate}
\item
{\tt chord.dlogmap.path}

The path specifying the mapping from the name of each Datalog-based program
analysis that must be included in the project to the location
of the file defining that program analysis.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <file-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:' on UNIX and `;' on Windows).

Let \DlogMapEntries\ denote the set of all entries of the
above form.

\item
{\tt chord.trgtmap.path}

The path partially specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be
included in the project to the fully-qualified name of a subclass, either
pre-defined in \Chord\ or defined by the user, of {\tt chord.Dom},
{\tt chord.Ary*Rel}, and
{\tt chord.Entity}, respectively, the instance fields of which define the
state of the corresponding domain, relation, or analysis.
The `{\tt *}' in {\tt chord.Ary*Rel} is 1, 2, ..., 6, or N for
program relations of arity 1, 2, ..., 6, or $>$ 6, respectively.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:` on UNIX and ';' on Windows).

Let \TaskMapEntries\ denote the set of all entries of the
above form.

\item
{\tt chord.taskmap.path}

The path partially specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be included in
the project to the fully-qualified name of a
subclass, either pre-defined in \Chord\ or defined by the user, of
{\tt chord.Dom}, {\tt chord.Ary*Rel}, and {\tt chord.Entity}, respectively,
which define the following instance methods:
\begin{itemize}
\item
the {\tt execute} method specifying
the computation that updates the state of the corresponding domain, relation,
or analysis,
\item
the {\tt invalidate} method specifying the action to be taken when the
state of the corresponding domain, relation, or analysis is invalidated.
\item
the {\tt getConsumedNames} method specifying names of any domains, relations,
and Datalog-based or Java-based program analyses upon whose state the
computation depends, and
\item
the {\tt getProducedNames} method specifying names of any domains, relations,
and Datalog-based or Java-based program analyses whose state depends upon
the computation.
\end{itemize}

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator
character (e.g., `:` on UNIX and ';' on Windows).

Let \TrgtMapEntries\ denote the set of all entries of the above form.
\end{enumerate}

Then, \Chord\ uses the values of \DlogMapEntries, \TaskMapEntries, and \TrgtMapEntries\ 
to do the following:

\begin{enumerate}
\item
Compute {\tt Tasks\ :\ Set<chord.Entity>}, the set of all tasks,
each of which is an object of (a subclass of) {\tt chord.Entity},
as follows:

\begin{enumerate}
\item
For each entry in \DlogMapEntries\ (i.e., a Datalog-based program analysis,
there is a unique task, namely, a unique object of class {\tt chord.DatalogAnalysis}.

\item
For each entry in \TaskMapEntries\ (i.e., of the form {\tt <name> <class-name>} specifying
a program domain, a program relation, or a Java-based program analysis), there is a
unique task, namely, a unique object
of the class named {\tt <class-name>} which must be (a subclass of) {\tt chord.Dom} in the
case of a program domain, (a subclass of) {\tt chord.Ary*Rel} in the case of a
program relation, and (a subclass of) {\tt chord.Entity} in the case of a Java-based
program analysis.
\end{enumerate}

\item
Compute the following maps as shown below:

{\tt ConsumedNameToTasksMap\ :\ String -> Set<Task>},
mapping each name to the set of (possibly empty) tasks that consume that name.

{\tt NameToTaskMap\ :\ String -> Task},
mapping each name to the unique task that produces that name.

\Chord\ reports an error if a name is produced by no task or by more than one task.
{\small 
\begin{verbatim}
for each (<task> in Tasks) {
    case <task> came from item 1(a) above: {
        // <task> corresponds to a Datalog-based program analysis
        for each (<name> declared as input relation) {
            add <task> to ConsumedNameToTasksMap(<name>)
        }
        for each (<name> declared as output relation) {
            if (<name> is in domain of map NameToTaskMap)
                error ``multiple tasks produce name <name>''
            else
                NameToTaskMap(<name>) = <task>
        }
    }
    case <task> came from item 1(b) above: {
        // <task> corresponds to a program domain, a program relation, or
        // a Java-based program analysis
        // Suppose <task> came from entry <name> <class-name> in
        // TaskMapEntries
        // i.e. <task> is an object of class named <class-name>
        for each (<name2> in <task>.getConsumedNames())
            add <task> to ConsumedNameToTaskMaps(<name2>)
        for each (<name2> in <task>.getProducedNames() union { <name> })
            if (<name2> is in domain of map NameToTaskMap)
                error ``multiple tasks produce name <name>''
            else
                NameToTaskMap(<name2>) = <task>
    }
}
\end{verbatim}
}

{\small 
\begin{verbatim}
for each (<name> in domain of map ConsumedNameToTasksMap) {
    if (<name> is not in domain of map NameToTaskMap)
        error ``no task produces name <name>''
}
\end{verbatim}
}

\item
Compute \NameToTrgtMap : {\tt String -> Entity},
mapping each name to a unique target, as below.
\Chord\ reports an error if a name is mapped to multiple targets
or to no target.

{\small 
\begin{verbatim}
for each (entry <name> <class-name> in TaskMapEntries) {
    if (<name> is in domain of map NameToTrgtMap)
        error ``name <name> mapped to multiple targets''
    NameToTrgtMap(<name>) = NameToTaskMap(<name>)
}
for each (entry <name> <class-name> in TrgtMapEntries) {
    if (<name> is in domain of map NameToTrgtMap)
        error ``name <name> mapped to multiple targets''
    NameToTrgtMap(<name>) = a fresh object of class named <class-name>
}
\end{verbatim}
}

To reduce user burden in providing \TaskMapEntries\ and
\TrgtMapEntries, \Chord\ implicitly extends \NameToTrgtMap\ using
\DlogMapEntries\ as follows:

{\small 
\begin{verbatim}
for each (<name> in domain of map NameToTaskMap) {
    if (<name> is not in domain of map NameToTrgtMap) {
        if (<name> is declared as a domain in some datalog file in DlogMapEntries)
            NameToTrgtMap(<name>) = a fresh object of class chord.Dom
        else if (<name> is declared as a (input or output) relation
                in some datalog file in DlogMapEntries)
            NameToTrgtMap(<name>) = a fresh object of class chord.Rel
        else
            error ``<name> not mapped to any target''
    } else {
        chord.Entity <trgt> = NameToTrgtMap(<name>)
        if (<name> is declared as a domain in some datalog file in DlogMapEntries
                and <trgt> is not of type (subclass of) chord.Dom)
            error ``<name> has conflicting types''
        else if (<name> is declared as a (input or output) relation
                in some datalog file in DlogMapEntries
                and <trgt> is not of type (subclass of) chord.Rel)
            error ``<name> has conflicting types''
    }
}
\end{verbatim}
}

\item
Compute graph \TaskGraph\ as a graph whose:

\begin{itemize}
\item
set of nodes is \Tasks\ and
\item
set of edges containing an edge from task {\tt <task1>} to task {\tt <task2>} 
whenever there exists a name {\tt <name>} such that
\NameToTaskMap({\tt <name>}) = {\tt <task1>} and
\ConsumedNameToTasksMap({\tt <name>}) contains {\tt <task2>}.
\end{itemize}

The task graph in XML and HTML formats is dumped to files {\tt taskgraph.xml}
and {\tt taskgraph.html} in the project's working directory specified using
system property {\tt chord.work.dir}.

\end{enumerate}

\texonly{\newpage}
\section{Executing Targets}

\Chord\ interprets system property {\tt chord.trgts}, if defined, as
a space-separated list of names of program domains, program relations, and
Datalog-based or Java-based program analyses, denoted \TrgtNames,
to be computed in that order.

To avoid redundant computation, \Chord\ maintains during its execution a set of
up-to-date tasks, denoted \ValidTasks,
which is a subset of the set of all tasks, denoted \Tasks.
Set \ValidTasks\ is empty at startup.
A future release of \Chord\ may provide the ability to retrieve a set of up-to-date tasks from
a previous run of \Chord\ to prevent re-computing those tasks in subsequent runs.
The following procedure is executed upon startup:

{\small
\begin{verbatim}
for each (<name> in TrgtNames in order) {
    if (<name> is not in domain of map NameToTaskMap) {
        error ``name <name> is an invalid target name''
    else {
        chord.Entity <task> = NameToTaskMap(<name>)
        executeTask(<task>)
    }
}
\end{verbatim}
}

\noindent where procedure {\tt executeTask} is defined as follows:

{\small
\begin{verbatim}
procedure executeTask(chord.Entity <task>) {
    if (<task> is not in ValidTasks) {
        for each (immed. pred. <task2> of <task> in TaskGraph)
            executeTask(<task2>)
        <task>.execute()
        for each (immed. succ. <task2> of <task> in TaskGraph)
            invalidateTask(<task2>)
        add <task> to ValidTasks
    }
}
\end{verbatim}
}

\noindent where procedure {\tt invalidateTask} is defined as follows:

{\small
\begin{verbatim}
procedure invalidateTask(chord.Entity t) {
    if (<task> is in ValidTasks) {
        remove <task> from ValidTasks
        <task>.invalidate()
        for each (immed. succ. <task2> of <task> in TaskGraph)
            invalidateTask(<task2>)
    }
}
\end{verbatim}
}

\texonly{\newpage}
\section{Chord System Properties}
\label{sec-sys-props}

\Chord\ recognizes the following system properties:

\begin{itemize}
\item
{\tt chord.out}

The location of a file to which the standard output stream
of \Chord's execution is redirected.

It may be the same file to which the standard error stream is redirected (see
the description of system property {\tt chord.err}).

The file is created if it does not exist and its contents are overwritten if it exists.

\item
{\tt chord.err}

The location of a file to which the standard error stream
of \Chord's execution is redirected.

It may be the same file to which the standard output stream is redirected (see
the description of system property {\tt chord.out}).

The file is created if it does not exist and its contents are overwritten if it exists.

\item
{\tt chord.program.builder.class}

The fully-qualified name of the class to be used for building the
intermediate representation of the program to be analyzed.
It must be a concrete class with a nullary constructor that
implements interface {\tt chord.program.builders.IProgramBuilder}.

The default value of this property is {\tt chord.program.builders.SootProgramBuilder}
which uses the Soot Java compiler framework \cite{Soot}.

\item
{\tt chord.program.file}

The location of a file from (resp.\ to) which
the serialized form of the intermediate representation of the
program to be analyzed is loaded (resp.\ stored).

\item
{\tt chord.app.class.path}

The application classpath of the program to be analyzed (as opposed to the
JDK library classpath which consists of jar files {\tt rt.jar}, {\tt jsse.jar}, and
{\tt jce.jar} and is implicitly appended to the program's application classpath to
yield the complete program classpath).

Each path element must be the location of a directory or a jar/zip file.

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

This system property (and either {\tt chord.main.class} or {\tt chord.root.classes}) must
be defined if system property {\tt chord.program.file}
does not specify the file containing the serialized form of the intermediate representation
of the program to be analyzed.

\item
{\tt chord.main.class}

The fully-qualified name of the main class (e.g., {\tt com.example.Main}) of the
program to be analyzed if the program is a complete one.

This system property (and {\tt chord.app.class.path})
must be defined if system property {\tt chord.program.file}
does not specify the file containing the serialized form of the intermediate representation
of the program to be analyzed.

\item
{\tt chord.root.classes}

A space-separated list of fully-qualified names of classes (e.g., {\tt com.example.Main})
whose public methods must be regarded as root methods (i.e., entry points) if the program
is an incomplete one.

This system property (and {\tt chord.app.class.path} plus, optionally,
system properties {\tt chord.include.root.methods} and {\tt chord.exclude.root.methods})
must be defined if system property {\tt chord.program.file}
does not specify the file containing the serialized form of the intermediate representation
of the program to be analyzed.

\item
{\tt chord.include.root.methods}

A space-separated list of fully-qualified signatures of
methods (e.g., {\tt com.example.Foo.bar(int,com.example.Baz[])}) that must be included
into the set of root methods (i.e., entry points)
if the program is an incomplete one.

\item
{\tt chord.exclude.root.methods}

A space-separated list of fully-qualified signatures of
methods (e.g., {\tt com.example.Foo.bar(int,com.example.Baz[])}) that must be excluded
from the set of root methods (i.e., entry points)
if the program is an incomplete one.

\item
{\tt chord.java.src.path}

The Java source path of the program to be analyzed.

Each path element must be the location of a directory.

The purpose of this path is to provide the location of the
{\tt .java} files of the program being analyzed so that, for instance, the
results of an analysis (which operates on an intermediate representation of the program
extracted from {\tt .class} files) can be mapped to the corresponding {\tt .java}
files and presented to the user for manual inspection.

Each file having suffix {\tt .java} in a directory (or a sub-directory of a directory)
specified in this path is regarded as a source file of the program.

\item
{\tt chord.dlogmap.path}

The path specifying the mapping from the name of each Datalog-based program
analysis that must be included in the project to the location
of the file defining that program analysis.

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <file-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

\item
{\tt chord.taskmap.path}

The path specifying the mapping from the name of each program domain, program relation,
and Java-based program analysis that must be included in the project to the
fully-qualified name of a subclass, either pre-defined in \Chord\ or defined by the user, of
{\tt chord.Dom}, {\tt chord.Ary*Rel}, and {\tt chord.Entity}, respectively, which
define the following instance methods:
\begin{itemize}
\item
the {\tt execute} method specifying
the computation that updates the state of the corresponding domain, relation,
or analysis, 
\item
the {\tt invalidate} method specifying the action to be taken when the
state of the corresponding domain, relation, or analysis is invalidated.
\item
the {\tt getConsumedNames} method specifying names of any domains, relations,
and analyses upon whose state the computation depends, and
\item
the {\tt getProducedNames} method specifying names of any domains, relations,
and analyses whose state depends upon the computation.
\end{itemize}

Each path element must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).

\item
{\tt chord.trgtmap.path}

The path specifying the mapping from the name of each program domain,
program relation, and Java-based program analysis that must be
included in the project to the fully-qualified name of a subclass,
either pre-defined in \Chord\ or defined by the user, of {\tt chord.Dom},
{\tt chord.Ary*Rel}, and
{\tt chord.Entity}, respectively, the instance fields of which define the
state of the corresponding domain, relation, or analysis.

Each path element in the list must be the location of a file containing a
list of entries (one per line) of the form:

{\tt <name> <class-name>}

The path elements must be separated by the system-specific path separator character
(e.g., `:` on UNIX and ';' on Windows).

\item
{\tt chord.trgts}

A space-separated list of the names of program domains, program relations, and
Java-based or Datalog-based program analyses that must be computed in that order.

\item
{\tt chord.ext.class.path}

The classpath of user-defined program domains, user-defined program relations,
and user-defined Java-based program analyses.
It is implicitly appended to the classpath of pre-defined program domains,
pre-defined program relations, and pre-defined Java-based program analyses
to yield the complete runtime classpath of \Chord.

Each path element must be the location of a directory or a jar/zip file.

The path elements must be separated by the system-specific path separator character
(e.g., `:' on UNIX and `;' on Windows).
\end{itemize}

\texonly{\newpage}
\section{Pre-defined Domains}
\label{sec-predef-domains}

The following domains are pre-defined in \Chord:

\begin{itemize}
\item
$\Cdom$

The domain of all k-object-sensitive contexts.

The $0^{th}$ element in this domain denotes a distinguished hypothetical
context (denoted \texorhtml{$\epsilon$}{{\it epsilon}} in the literature) that is regarded as the
lone abstract context in which certain static methods are analyzed.
The main static method with signature {\tt void main(java.lang.String[])}
has no callers and is therefore analyzed in this context.
For simplicity, the k-object-sensitive may alias analysis provided in
\Chord\ also analyzes each class initializer method in this context.

\item
$\Edom$

The domain of all statements that access (read or write) an instance field,
a static field, or an array element, namely, all statements
represented by instances of (subclasses of) {\tt chord.program.insts.HeapInst}.

\item
$\Fdom$

The domain of  all instance and static fields.

The $0^{th}$ element in this domain denotes a distinguished hypothetical
field that is regarded as accessed whenever an array element is
accessed.

\item
$\Hdom$

The domain of all object allocation statements, namely, all statements
represented by instances of {\tt chord.program.insts.ObjValAsgnInst}.

\item
$\Idom$

The domain of all method invocation statements, namely, all statements
represented by instances of {\tt chord.program.insts.InvkInst}.

\item
$\Mdom$

The domain of all instance and static methods.

The $0^{th}$ element in this domain is the main method of the program.

The $1^{st}$ element in this domain is the method with signature
{\tt void start()} of class {\tt java.lang.Thread}, if this
method is deemed reachable from the main method of the program.

The above two methods are the root methods of the implicitly spawned
main thread and each explicitly spawned child thread, respectively.
Due to \Chord's emphasis on concurrency, these methods are
referenced frequently by various pre-defined program analyses
expressed in Datalog, and giving them special indices makes it
convenient to reference them in those analyses.

\item
$\Pdom$

The domain of all simple statements, namely, all statements
represented by instances of (subclasses of) {\tt chord.program.insts.Inst}.

The $0^{th}$ element in this domain is the statement at the unique
entry point of the main method of the program.

The statements of each method in the program are assigned
contiguous indices in this domain, with the statements at the
unique entry and exit points of each method being assigned
the smallest and largest indices, respectively, of all
indices assigned to statements in that method.

\item
$\Tdom$

The domain of all types, including the types of classes, interfaces,
arrays, and primitives.

\item
$\Vdom$

The domain of all local variables.

Each local variable declared in each block of each method is
represented by a unique element in this domain, in particular,
local variables that have the same name but are declared in
different methods or in different blocks of the same method
are represented by different elements in this domain.

All local variables of the same method are assigned contiguous
indices in this domain, in particular, the set of local
variables of a method is the disjoint union of its argument
variables and its temporary variables, and the argument
variables are assigned contiguous indices in order followed by
the temporary variables.

\item
$\Zdom$

The domain of all argument and return variable positions.
Let $N$ be the largest number or arguments or return variables of any
method.  Then, this domain contains the $N$ elements $0, 1, ..., N-1$.
\end{itemize}

\texonly{\newpage}
\section{Pre-defined Relations}
\label{sec-predef-relations}

The following relations are pre-defined in \Chord:

\begin{itemize}

\item
$\cha : \Mdom \times \Tdom \times \Mdom$

Relation containing each tuple $(m_1,t,m_2)$ such that $m_2$ is
the target method of a method invocation statement whose {\it resolved method}
is $m_1$ and whose receiver has run-time type $t$.
It is named $\cha$ because it represents the relation
computed by Class Hierarchy Analysis.

\item
$\sub : \Tdom \times \Tdom$

Relation containing each tuple $(s,t)$ such that type $s$ is a
subtype of type $t$.

\item
$\HT : \Hdom \times \Tdom$

Relation containing each tuple $(h,t)$ such that object allocation
statement $h$ allocates objects of type $t$.

\item
$\VT : \Vdom \times \Tdom$

Relation containing each tuple $(v,t)$ such that local variable $v$
has type $t$.

\item
$\MH : \Mdom \times \Hdom$

Relation containing each tuple $(m,h)$ such that method $m$ contains
object allocation statement $h$.

\item
$\MI : \Mdom \times \Idom$

Relation containing each tuple $(m,i)$ such that method $m$ contains
method invocation statement $i$.

\item
$\ME : \Mdom \times \Edom$

Relation containing each tuple $(m,e)$ such that method $m$ contains
statement $e$ that accesses (reads or writes) an instance field, a
static field, or an array element.

\item
$\instM : \Mdom$

Relation containing all instance (as opposed static) methods.

\item
$\statM : \Mdom$

Relation containing all static (as opposed instance) methods.

\item
$\clinitM : \Mdom$

Relation containing all class initializer methods, namely,
methods having signature {\tt void <clinit>()}.

\item
$\IinvkArg : \Idom \times \Zdom \times \Vdom$

Relation containing each tuple $(i,z,v)$ such that local variable $v$
is the $z^{th}$ argument variable of method invocation statement $i$.

\item
$\IinvkRet : \Idom \times \Zdom \times \Vdom$

Relation containing each tuple $(i,z,v)$ such that local variable $v$
is the $z^{th}$ return variable of method invocation statement $i$.

\item
$\MmethArg : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable
$v$ is the $z^{th}$ argument variable of method $m$.

\item
$\MmethRet : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable
$v$ is the $z^{th}$ return variable of method $m$.

\item
$\MspcMethArg : \Mdom \times \Vdom$

Relation containing each tuple $(m,v)$ such that local variable $v$ is
the implicit {\tt this} argument variable of instance method $m$.

\item

$\MordMethArg : \Mdom \times \Zdom \times \Vdom$

Relation containing each tuple $(m,z,v)$ such that local variable $v$
is the $z^{th}$ argument variable of method $m$ other than the implicit
{\tt this} argument variable (in the case in which $m$ is an instance
method).

\item
$\MobjVarAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,r)$ such that method $m$
contains a copy statement of the form $l = r$ where $l$ and $r$ are
local variables.

\item
$\MobjValAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,h)$ such that method $m$ contains
object allocation statement $h$ which assigns to local variable $l$.

\item
$\MclsVarAsgnInst : \Mdom \times \Vdom \times \Vdom$

Relation containing each tuple $(m,l,b)$ such that method $m$
contains a statement of the form $l = b.{\tt getClass()}$.

\item
$\MgetInstFldInst : \Mdom \times \Vdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,b,f,r)$ such that method $m$
contains a statement of the form $b.f = r$ which assigns to
instance field or array element $f$ of the object denoted by local
variable $b$ the value denoted by local variable $r$.

\item
$\MputInstFldInst : \Mdom \times \Vdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,b,f,r)$ such that method $m$
contains a statement of the form $b.f = r$ which writes the value
denoted by local variable $r$ to instance field or array element
$f$ of the object denoted by local variable $b$.

\item
$\MgetStatFldInst : \Mdom \times \Vdom \times \Fdom$

Relation containing each tuple $(m,l,f)$ such that method $m$ contains
a statement of the form $l = f$ that assigns to local variable $l$ the
value denoted by static field $f$.

\item
$\MputStatFldInst : \Mdom \times \Fdom \times \Vdom$

Relation containing each tuple $(m,f,r)$ such that method $m$ contains
a statement of the form $f = r$ which assigns to static field $f$ the
value denoted by local variable $r$.

\item
$\virtIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokevirtual} or {\tt invokeinterface} method
invocation statement $i$.

\item
$\statIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokestatic} method invocation statement $i$.

\item
$\specIM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that $m$ is the
{\it resolved method} of {\tt invokespecial} method invocation statement $i$.

\item
$\syncMV : \Mdom \times \Vdom$

Relation containing each tuple $(m,v)$ such that method $m$ is
synchronized on argument variable $v$.

\item
$\writeE : \Edom$

Relation containing all statements that write (as opposed to read)
an instance field, static field, or array element.

\item
$\EF : \Edom \times \Fdom$

Relation containing each tuple $(e,f)$ such that statement $e$
accesses (reads or writes) instance field, static field, or
array element $f$.

\item
$\VH : \Vdom \times \Hdom$

Relation containing each tuple $(v,h)$ such that local variable $v$
may point to abstract object $h$, as determined by 0CFA-based may
alias analysis.

\item
$\FH : \Fdom \times \Hdom$

Relation containing each tuple $(f,h)$ such that static field $f$ may
point to abstract object $h$, as determined by 0CFA-based may alias
analysis.

\item

$\HFH : \Hdom \times \Fdom \times \Hdom$

Relation containing each tuple $(h_1,f,h_2)$ such that instance field
or array element $f$ of abstract object $h_1$ may point to abstract
object $h_2$, as determined by 0CFA-based may alias analysis.

\item
$\IM : \Idom \times \Mdom$

Relation containing each tuple $(i,m)$ such that method invocation
statement $i$ may call method $m$ as determined by 0CFA-based may alias
analysis.

\item
$\nestedLocks : \Cdom \times \Cdom \times \Mdom \times \Cdom \times \Mdom$

Relation containing each tuple $(c,c_1,m_1,c_2,m_2)$ such that in the
context-sensitive call graph computed by k-object-sensitive may
alias analysis, abstract thread $c$ may first acquire the lock at
the entry of method $m_1$ in abstract context $c_1$ and without
releasing it proceed to acquire the lock at the entry of method
$m_2$ in abstract context $c_2$.

\item
$\forkC : \Cdom$

Relation containing all abstract contexts in which the
{\tt start()} method of class {\tt java.lang.Thread} may
be reachable from the main method, as determined by
k-object-sensitive may alias analysis.

\item
$\CVC : \Cdom \times \Vdom \times \Cdom$

Relation containing each tuple $(c_1,v,c_2)$ such that local variable
$v$ may point to abstract object $c_2$ in abstract context $c_1$ of its
containing method, as determined by k-object-sensitive may alias
analysis.

\item
$\FC : \Fdom \times \Cdom$

Relation containing each tuple $(f,c)$ such that static field $f$
may point to abstract object $c$, as determined by k-object-sensitive
may alias analysis.

\item
$\CFC : \Cdom \times \Fdom \times \Cdom$

Relation containing each tuple $(c_1,f,c_2)$ such that instance field
or array element $f$ of abstract object $c_1$ may point to abstract
object $c_2$, as determined by k-object-sensitive may alias analysis.

\item
$\CICM : \Cdom \times \Idom \times \Cdom \times \Mdom$

Relation containing each tuple $(c_1,i,c_2,m)$ such that method
invocation statement $i$ in abstract context $c_1$ of its containing method
may call method $m$ in abstract context $c_2$, as determined by
k-object-sensitive may alias analysis.

\item
$\CHC : \Cdom \times \Hdom \times \Cdom$

Relation containing each tuple $(c_1,h,c_2)$ such that the method
containing object allocation statement $h$ may be reachable in
abstract context $c_1$, and $c_2 = (h::c_1) + k$, where $k$ is the k
value of statement $h$, provided as an argument to k-object-sensitive
may alias analysis.

\end{itemize}

\texonly{\newpage}
\section{Pre-defined Datalog-based Analyses}
\label{sec-predef-datalog-analyses}

\texonly{\newpage}
\section{Pre-defined Java-based Analyses}
\label{sec-predef-java-analyses}

\texonly{\newpage}
\bibliographystyle{plain}
\bibliography{citations}

\end{document}

\newpage
\section{Defining Tasks and Targets}

\Chord\ uses the notion of {\it tasks} to express computations
and the notion of {\it targets} to express the structure of
inputs/outputs of computations.

Tasks and targets are both implemented uniformly as {\it entities}.
A generic entity is represented by class {\tt chord.Entity}
depicted in Figure \ref{fig-entity}.

\begin{figure}
\begin{verbatim}
public class Entity {
    protected static final String[] emptyStringArray = new String[0];
    // subclasses may override
    public void execute() {
        // do nothing
    }
    // subclasses may override
    public String[] getConsumedTargetNames() {
        return emptyStringArray;
    }
    // subclasses may override
    public String[] getProducedTargetNames() {
        return emptyStringArray;
    }
    ...
}
\end{verbatim}
\caption{Snippet of class {\tt chord.Entity}}
\label{fig-entity}
\end{figure}

Whenever an enntity is regarded as a task:

\begin{itemize}
\item
The {\tt execute} method defines the computation that must be performed by the task.

\item
The {\tt getConsumedTargetNames} method specifies the names of targets
that are inputs to (the computation performed by) the task.

\item
The {\tt getProducedTargetNames} method specifies the names of targets
that are outputs of (the computation performed by) the task.
\end{itemize}

There are four kinds of entities:
\begin{itemize}
\item
A program domain

\item
A program relation

\item
A program analysis expressed in Datalog

\item
A program analysis expressed in Java

\end{itemize}

We next describe each of these kinds of entities in detail.

\subsection{Program Domains}

A program domain is a set of related elements in a given program (e.g.,
the set of all methods, the set of all object allocation statements, etc.).
The structure of a generic program domain is represented by
class {\tt chord.Dom} depicted in Figure \ref{fig-dom}.

\begin{figure}
\begin{verbatim}
public class Dom<T> extends Entity {
    public final IndexMap<T> map;
    public Dom() {
        this.map = new IndexMap<T>();
    }
    public void execute() {
        populate();
        saveToDomFile();
    }
    // subclasses cannot override
    public final String[] getProducedTargetNames() {
        return emptyStringArray;
    }
    // subclasses may override
    protected void populate() {
        // do nothing
    }
    ...
\end{verbatim}
\caption{Snippet of class {\tt chord.Dom}}
\label{fig-dom}
\end{figure}

A program domain provides a map from each element in the domain
to a unique integer in the range $[0..n-1]$ where $n$ is the size of
the domain.
This map is required by {\tt bddbddb} (a BDD-based Datalog solver).
The {\tt execute} method is specialized to construct the map and then
save the map to disk for use by {\tt bddbddb}.
Subclasses must override the {\tt populate} method to construct the
map as desired.

It is not possible to override the {\tt getProducedTargetNames}
method (note that it is declared {\tt final}) because a program domain
task is a specialized task whose output is exactly one target, namely,
the program domain it constructs.
It is, however, possible to override the {\tt getConsumedTargetNames}
method (inherited from superclass {\tt chord.Entity}) since constructing
a program domain may require other targets (i.e., other program
domains, program relations, or program analyses).

Figure \ref{fig-domI} defines the program domain
named $\Idom$ as the domain of all method invocation statements.
Note from method {\tt getConsumedTargetNames} that it takes as input
the domain named $\Mdom$ which is the domain of all methods.
This is because the {\tt populate} method refers to that domain.
Intuitively, the {\tt populate} method gives adjacent indices in
domain $\Idom$ to method invocation statements contained in
methods that have adjacent indices in domain $\Mdom$ are given
adjacent indices in domain $\Idom$.

\begin{figure}
\begin{verbatim}
public class DomI extends Dom<InvkInst> {
    private IndexMap<Method> mapM;
    private final String[] consumedTaskNames = new String[] { "M" };
    public String[] getConsumedTargetNames() {
        return consumedTaskNames;
    }
    protected void populate() {
        DomM domM = (DomM) project.getEntity("M");
        mapM = domM.map;
        for (int m = 0; m < mapM.size(); m++) {
            Method meth = mapM.get(m);
            Body body = meth.body;
            if (body == null)
                continue;
            Set<Inst> insts = body.cfg.getNodes();
            for (Inst inst : insts) {
                if (inst instanceof InvkInst)
                    map.set((InvkInst) inst);
            }
        }
    }
    ...
}
\end{verbatim}
\caption{Snippet of class {\tt chord.DomI}}
\label{fig-domI}
\end{figure}

A list of pre-defined program domains is presented in Section \ref{sec-predef-domains}.

\subsection{Program Relations}

A program relation is a relation over one or more program domains.
The structure of a generic program relation is represented by class
{\tt chord.Rel} depicted in Figure \ref{fig-rel}.

\begin{figure}
\begin{verbatim}
\end{verbatim}
\caption{Snippet of class {\tt chord.Rel}}
\label{fig-rel}
\end{figure}

It is not possible to override the {\tt getProducedTargetNames}
method (note that it is declared {\tt final}) because a program relation
task is a specialized task whose output is exactly one target, namely,
the program relation it constructs.
It is, however, possible to override the {\tt getConsumedTargetNames}
method (inherited from superclass {\tt chord.Entity}) since constructing
a program relation may require other targets (i.e., program
domains, other program relations, or program analyses).

A list of pre-defined program relations is presented in Section \ref{sec-predef-relations}.

\subsection{Program Analyses in Datalog}

A list of pre-defined program analyses in Datalog is presented in
Section \ref{sec-predef-datalog-analyses}.

\subsection{Program Analyses in Java}

A list of pre-defined program analyses in Java is presented in
Section \ref{sec-predef-java-analyses}.

\texonly{\newpage}
\section{Program Transformations}
\label{sec-prog-transform}

After building the intermediate representation of the
program, \Chord\ performs
the following source-to-source transformations 
that simplify several program analyses:

\begin{enumerate}
\item
{\bf Sync Removal}

Removes all synchronized blocks from each method M in each class
C in the program by generating a fresh static method (in class C)
per synchronized block in the body of M.

\item
{\bf Loop Removal}

Removes all loops from each method M in each class C in the program
by generating a fresh static method (in class C)
per loop in the body of M.

\item
{\bf Skip Removal}

Removes all skip (i.e., no-op) statements from each method in each class
in the program.
Such statements arise primarily because \Chord, due to its emphasis
on the analysis of objects, replaces each
statement in the original program that does not access any
value of reference type (i.e., only accesses values of primitive
type) by a skip statement.

\end{enumerate}

