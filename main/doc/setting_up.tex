\section{Setting up a Java Program}
\label{sec:setting-up}

Suppose the program to be analyzed has the following directory structure:

\begin{verbatim}
    example/
        src/
            foo/
                Main.java
                ...
        classes/
            foo/
                Main.class
                ...
        lib/
            src/
                taz/
                    ...
            jar/
                taz.jar
        chord.properties
\end{verbatim}

The above structure is typical: the program's Java source
files are under {\tt src/}, its class files are under {\tt classes/},
the source and jar files of the libraries used by the program are
under \code{lib/src/} and \code{lib/jar/}, respectively.

To run Chord on the above program, run the following command in
Chord's {\tt main/} directory:

\begin{verbatim}
    prompt> ant -Dchord.work.dir=<...>/example run
\end{verbatim}

where \code{<...>} denotes the absolute or relative path of the
directory containing the above \code{example/} directory.
Property \code{chord.work.dir} specifies the working directory during Chord's execution.
Chord searches for a file named \code{chord.properties} under that working directory, and
loads upfront all properties defined in that file, if it exists.  Alternatively, these properties
may be defined on the command-line, using the \code{-D<key>=<value>} format.
A sample \code{chord.properties} file for the above program is as follows:

\begin{verbatim}
    chord.main.class=foo.Main
    chord.class.path=classes:lib/jar/taz.jar
    chord.src.path=src:lib/src
    chord.run.ids=0,1
    chord.args.0="-thread 1 -n 10"
    chord.args.1="-thread 2 -n 50"
\end{verbatim}

Each relative file/directory name in the value of any property
defined in this file (e.g., the \code{lib/src} directory name in the value of
property \code{chord.src.path} above) is treated relative to Chord's working directory
(which is specified by property \code{chord.work.dir}).

Section \ref{sec:chord-sysprops} presents an exhaustive listing of
properties recognized by Chord.  Here, we only describe those defined
in the above sample \code{chord.properties} file:

\begin{itemize}
\item
\code{chord.main.class} specifies the fully-qualified name of the main
class of the program.
\item
\code{chord.class.path} specifies the application classpath
of the program (the standard library classpath is implicitly
included).
\item
\code{chord.src.path} specifies the Java source path of the program.
All program analyses in Chord operate on Java bytecode.  The only use
of this property is to HTMLize the Java source files of the program so
that the results of program analyses can be reported at the Java
source code level.
\item
\code{chord.run.ids} specifies a list of IDs to identify runs of the
program.  It is used by dynamic program analyses to determine how many
times the program must be run.  An additional use of this property is
to allow specifying the command-line arguments to use in the run
having ID {\tt <id>} via property \code{chord.args.<id>}, as
illustrated by properties \code{chord.args.0} and \code{chord.args.1}
in the above example.
\end{itemize}

In the above case, Chord does not do much beyond loading the above
\code{chord.properties} file.  For Chord to do something interesting,
you need to set additional properties, either on the above command
line or in the \code{chord.properties} file, specifying the task(s)
Chord must perform.  All tasks are summarized under ``Functionality Properties"
in Section \ref{sec:chord-sysprops}.  The two most common tasks, described
next, are computing the analysis scope of the given program (Section
\ref{sec:computing-scope}) and running analyses on the given program
(Section \ref{sec:running-analysis}).

