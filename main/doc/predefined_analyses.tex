\xname{predefined_analyses}
\chapter{Predefined Analyses}
\label{chap:predefined-analyses}

This chapter describes various predefined analyses in Chord.

\section{Points-to and Call-Graph Analyses}

Chord offers several choices for computing points-to and call-graph information of Java programs.
In each of these choices, points-to and call-graph information is computed simultaneously
(called ``on-the-fly call-graph construction" in the literature in contrast to ``ahead-of-time call-graph
construction" in which the call graph is computed first followed by points-to information).
On-the-fly approaches are more precise because, in a dynamically dispatching language like Java,
as more points-to facts are discovered, more (dynamically dispatched) methods are deemed reachable,
thereby growing the call graph; the code in these newly added methods in turn results in more
points-to facts.

Flow-insensitive analysis computes a single abstract heap whereas flow-sensitive analysis computes
per-program-point abstract heaps.  Context-insensitive analysis analyzes each method at most once (i.e. in a single abstract context),
whereas context-sensitive analyses potentially analyze each method multiple times, in different abstract contexts.
Thus, flow- and context-sensitive analyses are more precise but less scalable than flow- and context-insensitive
analyses, respectively.

Flow-sensitive analysis does not offer much precision over flow-insensitive analysis in
practice, especially in the absence of strong updates and in the presence of SSA (Static Single Assignment form),
a program representation that renders a flow-insensitive analysis almost as precise as a flow-sensitive analysis.
Since analyses in Chord currently perform only weak updates, and since they all operate on an SSA form of the
input Java program by default, the rest of this section focuses only on flow-insensitive analysis, which is the predominant
kind of points-to/call-graph analysis in Chord.

We describe context-insensitive analysis first because understanding the concepts behind it will help understand
the more sophisticated context-sensitive analyses.
We first recall some relevant program domains:

\texonly{\newpage}

\begin{itemize}
\item M is the domain of all methods.
\item I is the domain of all method call sites.
\item F is the domain of all (instance and static) fields.
\item V is the domain of all local variables of reference type.
\item H is the domain of all object allocation sites.
\end{itemize}

\subsection{Context-Insensitive Analysis}

The context-insensitive points-to/call-graph analysis 
treats each object allocation site as a separate abstract memory location; in other words, it
can distinguish objects created at different sites but not those created at the same site.
Additionally, it is field-sensitive, in that it distinguishes between different instance fields of the same object,
but array-insensitive, in that it cannot distinguish between different elements of the same array;
all array elements are modeled using a distinguished hypothetical instance field (that has index 0 in domain F).

To run this analysis, run the following command in Chord's main directory:

\begin{framed}
\begin{verbatim}
ant -Dchord.work.dir=<...> -Dchord.run.analyses=cipa-0cfa-dlog run
\end{verbatim}
\end{framed}

This analysis outputs the following relations:

%is implemented in \code{chord/analyses/alias/cipa-0cfa.dlog}.

\begin{itemize}
\item
{\it Call-graph information:}
\begin{itemize}
\item rootM subset M contains the set of entry methods that may be reachable; this includes the program's main method
as well as each static initializer method that may be reachable from the main method.
\item reachableM subset M contains the set of methods that may be reachable from the program's main method.
\item IM subset (I $\times$ M) contains tuples \texttt{(i,m)} such that call site \texttt{i} may call method \texttt{m}.
%\item MM subset (M $\times$ M) contains tuples \texttt{(m1,m2)} such that method \texttt{m1} may call method \texttt{m2}.
%\item reachableI subset I contains the set of call sites that may be reachable.
%\item reachableT subset T contains the set of classes that may be reachable.
\end{itemize}
\item
{\it Points-to information:}
\begin{itemize}
\item FH subset (F $\times$ H) contains tuples \texttt{(f,h)} such that static field (i.e. global variable) \texttt{f} may point to an object allocated at site \texttt{h}.
\item VH subset (V $\times$ H) contains tuples \texttt{(v,h)} such that local variable \texttt{v} may point to an object allocated at site \texttt{h}.
\item HFH subset (H $\times$ F $\times$ H) contains tuples \texttt{(h1,f,h2)} such that instance field \texttt{f} of some object allocated at
site \texttt{h1} may point to some object allocated at site \texttt{h2}.
\end{itemize}
\end{itemize}

\subsection{Context-Sensitive Analysis}

In a context-sensitive analysis, there is no longer just one abstract memory location per object allocation site.
Rather, the set of objects a reference can point to depends on the \textit{context} in which the method containing the
reference is called.
Whereas a context-insensitive analysis talks about the domain of methods (M) and the domain
of allocation sites (H), a context-sensitive analysis talks about the domain of abstract contexts, labeled C.
Elements of domain C contain both abstract calling contexts and abstract objects. (These are merged for reasons
described below.)

Chord has several context-sensitive analyses, but they all expose the same relations, which are
described below:

\begin{itemize}
\item
{\it Context information:}
\begin{itemize}
\item C is the domain of all abstract calling contexts and abstract objects.  Each element in this domain is a sequence of zero or more sites,
where each site can be a call site or an object allocation site.  A sequence may have mixed call sites and object allocation sites.
The most significant site (i.e. the first site) in each sequence is called the head; the remaining sub-sequence is called the tail.  The
below three relations relate a sequence with its head and tail.
\item CC subset (C $\times$ C) contains tuples \texttt{(c1,c2)} such that context \texttt{c2} is the tail of context \texttt{c1}.
\item CH subset (C $\times$ H) contains tuples \texttt{(c,h)} such that object allocation site \texttt{h} is the head of context \texttt{c}.
\item CI subset (C $\times$ I) contains tuples \texttt{(c,i)} such that call site \texttt{i} is the head of context \texttt{c}.
\end{itemize}
\item
{\it Call-graph information:}
\begin{itemize}
\item rootCM subset (C $\times$ M) contains tuples \texttt{(c,m)} such that method \texttt{m} is an entry method in context \texttt{c}.
\item reachableCM subset (C $\times$ M) contains tuples \texttt{(c,m)} such that method \texttt{m} may be reachable in context \texttt{c}.
\item CICM subset (C $\times$ I $\times$ C $\times$ M) contains tuples \texttt{(c1,i,c2,m)} such that call site \texttt{i} in
context \texttt{c1} may call method \texttt{m2} in context \texttt{c2}.
\end{itemize}
\item
{\it Points-to information:}
\begin{itemize}
\item FC subset (F $\times$ C) contains tuples \texttt{(f,o)} such that static field (i.e. global variable) \texttt{f} may point to object \texttt{o}.
\item CVC subset (C $\times$ V $\times$ C) contains tuples \texttt{(c,v,o)} such that local variable \texttt{v} may point to
object \texttt{o} in context \texttt{c} of that variable's declaring method. Note that both \texttt{o} and \texttt{c} are elements of domain C.
\item CFC subset (C $\times$ F $\times$ C) contains tuples \texttt{(o1,f,o2)} such that instance field \texttt{f} of object \texttt{o1} may point to object \texttt{o2}.
\end{itemize}
\end{itemize}

{\bf Under Construction: explain object-sensitive vs context-sensitive, plus how to invoke.}

\section{Static Datarace Analysis}

To run Chord's static datarace analysis, run the following
command in Chord's main directory:

\begin{framed}
\begin{verbatim}
ant -Dchord.work.dir=<...> -Dchord.run.analyses=datarace-java run
\end{verbatim}
\end{framed}

where {\tt <...>} denotes the absolute or relative path of a directory
containing a file named \code{chord.properties} which defines
properties \code{chord.main.class}, \code{chord.class.path}, and
\code{chord.src.path}.  See Section \ref{sec:program-props} for the
meaning of these properties.

Directory \code{examples/datarace_test/} in Chord's main directory provides a toy Java
program on which one can run the datarace analysis.  First run {\tt
  ant} in that directory (in order to compile the program's {\tt
  .java} files to {\tt .class} files) and then run the above command
in Chord's main directory with {\tt <...>} replaced by
\code{examples/datarace_test/}.  Upon successful completion, the
following files should be produced in directory
\code{examples/datarace_test/chord_output/}:

\begin{itemize}
\item
File \code{dataraces_by_fld.html}, listing all dataraces grouped by
the field on which they occur; all dataraces on the same instance
field or the same static field are listed in the same group, and so
are all dataraces on array elements.
\item
File \code{dataraces_by_obj.html}, listing all dataraces grouped by
the abstract object on whose field they occur; dataraces on all static
fields are listed in the same group, and so are dataraces on different
instance fields of the same abstract object.
\end{itemize}

\section{Static Deadlock Analysis}

To run Chord's static deadlock analysis,  run the following
command in Chord's main directory:

\begin{framed}
\begin{verbatim}
ant -Dchord.work.dir=<...> -Dchord.run.analyses=deadlock-java run
\end{verbatim}
\end{framed}

where {\tt <...>} denotes the absolute or relative path of a directory
containing a file named \code{chord.properties} which defines
properties \code{chord.main.class}, \code{chord.class.path}, and
\code{chord.src.path}.  See Section \ref{sec:program-props} for the
meaning of these properties.

Directory \code{examples/deadlock_test/} in Chord's main directory provides a toy Java
program on which one can run the deadlock analysis.  First run {\tt
  ant} in that directory (in order to compile the program's {\tt
  .java} files to {\tt .class} files) and then run the above command
in Chord's main directory with {\tt <...>} replaced by
\code{examples/deadlock_test/}.  Upon successful completion, the
file \code{deadlocks.html} should be produced in directory
\code{examples/deadlock_test/chord_output/}.

