\xname{program_representation}
\chapter{Java Program Representation}
\label{chap:program-representation}

Chord uses \xlink{Joeq}{http://joeq.sourceforge.net/} to translate
Java bytecode, one class file at a time, into a three-address-like
intermediate representation of the input Java program called {\it
quadcode}.  This chapter describes how to pretty-print bytecode and
quadcode, which is useful for debugging analyses and deciphering their
output, as well as the API of Joeq and Chord that concerns bytecode
and quadcode, which is useful for users writing their own analyses.

\section{Pretty-Printing}

Consider the following Java program contained in
file \code{examples/hello_world/src/test/HelloWorld.java} in Chord's
main directory:
\begin{framed}
\begin{verbatim}
package test;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
\end{verbatim}
\end{framed}

First compile this program by running command \code{ant} in
directory \code{examples/hello_world/}.

To pretty-print the bytecode of a class, run the following command:
\begin{framed}
\begin{verbatim}
javap -classpath <...> -private -verbose <CLASS NAME>
\end{verbatim}
\end{framed}

where:

\begin{itemize}
\item
{\tt <CLASS NAME>} is the fully-qualified name of the class whose
bytecode is to be printed (\code{test.HelloWorld} in our example).
\item
\code{<...>} is the classpath of that class (\code{examples/hello_world/} in our example).
\end{itemize}

Program \code{javap} comes along with the JVM.  The output of the
above command for our example is as follows:

\begin{framed}
\begin{verbatim}
Compiled from "HelloWorld.java"
public class test.HelloWorld extends java.lang.Object
  SourceFile: "HelloWorld.java"
  minor version: 0
  major version: 49
  Constant pool:
const #1 = Method   #6.#20; //  java/lang/Object."<init>":()V
const #2 = Field    #21.#22;    //  java/lang/System.out:Ljava/io/PrintStream;
const #3 = String   #23;    //  Hello World!
const #4 = Method   #24.#25;    //  java/io/PrintStream.println:(Ljava/lang/String;)V
const #5 = class    #26;    //  test/HelloWorld
const #6 = class    #27;    //  java/lang/Object
const #7 = Asciz    <init>;
const #8 = Asciz    ()V;
const #9 = Asciz    Code;
const #10 = Asciz   LineNumberTable;
const #11 = Asciz   LocalVariableTable;
const #12 = Asciz   this;
const #13 = Asciz   Ltest/HelloWorld;;
const #14 = Asciz   main;
const #15 = Asciz   ([Ljava/lang/String;)V;
const #16 = Asciz   args;
const #17 = Asciz   [Ljava/lang/String;;
const #18 = Asciz   SourceFile;
const #19 = Asciz   HelloWorld.java;
const #20 = NameAndType #7:#8;//  "<init>":()V
const #21 = class   #28;    //  java/lang/System
const #22 = NameAndType #29:#30;//  out:Ljava/io/PrintStream;
const #23 = Asciz   Hello World!;
const #24 = class   #31;    //  java/io/PrintStream
const #25 = NameAndType #32:#33;//  println:(Ljava/lang/String;)V
const #26 = Asciz   test/HelloWorld;
const #27 = Asciz   java/lang/Object;
const #28 = Asciz   java/lang/System;
const #29 = Asciz   out;
const #30 = Asciz   Ljava/io/PrintStream;;
const #31 = Asciz   java/io/PrintStream;
const #32 = Asciz   println;
const #33 = Asciz   (Ljava/lang/String;)V;

{
public test.HelloWorld();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
   4:   return
  LineNumberTable:
   line 3: 0
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      5      0    this       Ltest/HelloWorld;

public static void main(java.lang.String[]);
  Code:
   Stack=2, Locals=1, Args_size=1
   0:   getstatic   #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc #3; //String Hello World!
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return
  LineNumberTable:
   line 5: 0
   line 6: 8
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      9      0    args       [Ljava/lang/String;
}
\end{verbatim}
\end{framed}

To pretty-print the quadcode of a class, run the following command:

\begin{framed}
\begin{verbatim}
ant -Dchord.work.dir=<...> -Dchord.print.classes=<CLASS NAME> \
    -Dchord.verbose=0 -Dchord.out.file=<FILE NAME> run
\end{verbatim}
\end{framed}

where:

\begin{itemize}
\item
\code{<...>} is the path of a directory (\code{examples/hello_world/} in our example) that is expected to
contain a file named \code{chord.properties} which defines
properties \code{chord.main.class} and \code{chord.class.path}
specifying the main class and the classpath of the input Java program
(alternatively, these two properties can be defined directly on the
above command line).
\item
{\tt <CLASS NAME>} is the name of the class whose quadcode is to be
printed.
\item
{\tt <FILE NAME>} is the name of a file to which the quadcode is to be
dumped.
\end{itemize}

The output of the above command for our example is as follows:

\begin{framed}
\begin{verbatim}
*** Class: test.HelloWorld
Method: main:([Ljava/lang/String;)V@test.HelloWorld
    0#1
    5#3
    5#2
    8#4
Control flow graph for main:([Ljava/lang/String;)V@test.HelloWorld:
BB0 (ENTRY) (in: <none>, out: BB2)

BB2 (in: BB0 (ENTRY), out: BB1 (EXIT))
1: GETSTATIC_A T1, .out
3: MOVE_A T2, AConst: "Hello World!"
2: INVOKEVIRTUAL_V println:(Ljava/lang/String;)V@java.io.PrintStream, (T1, T2)
4: RETURN_V

BB1 (EXIT)  (in: BB2, out: <none>)

Exception handlers: []
Register factory: Registers: 3
\end{verbatim}
\end{framed}

\section{Program}

The quadcode representation of the whole input Java program is a
unique global object of
class \javadoc{chord.program.Program}{chord/program/Program.html}
which can be obtained by calling static
method \javadoc{chord.program.Program.g()}{chord/program/Program.html\#g()}.
The various instance methods of this class provide access to various
parts of the quadcode representation, most notably:

\begin{mytable}{|l|p{4.3in}|}
\verb+IndexSet<jq_Type> getTypes()+ & Representation of all types referenced in classes that may be loaded at runtime. \\
\hline
\verb+IndexSet<jq_Reference> getClasses()+ & Representation of all classes that may be loaded at runtime.* \\
\hline
\verb+IndexSet<jq_Method> getMethods()+ & Representation of all methods that may be called at runtime.
\end{mytable}

* Includes both classes/interfaces and array types, represented as objects
of \code{jq_Class} and \code{jq_Array}, respectively (these are
subclasses of \code{jq_Reference}).

\section{Types}

The quadcode representation of each type in the input Java program is
an object of the appropriate class in the below hierarchy:

\begin{framed}
\begin{verbatim}
jq_Type
  |
  |--- jq_Primitive
  |
  |--- jq_Reference
            |
            |--- jq_Class
            |
            |--- jq_Array
\end{verbatim}
\end{framed}

\section{Class Members}

The quadcode representation of members (i.e., fields and methods) of a class/interface in the
input Java program can be accessed by calling instance methods of
the \code{jq_Class} object representing that class/interface, most
notably:

\begin{mytable}{|l|p{3in}|}
\verb+String getName()+ & Fully-qualified name of the class, e.g., ``\code{java.lang.String[]}''. \\
\hline
\verb+jq_InstanceField[] getDeclaredInstanceFields()+ & All instance fields declared in the class. \\
\hline
\verb+jq_StaticField[] getDeclaredStaticFields()+ & All static fields declared in the class. \\
\hline
\verb+jq_InstanceMethod[] getDeclaredInstanceMethods()+ & All instance methods declared in the class. \\
\hline
\verb+jq_StaticMethod[] getDeclaredStaticMethods()+ & All static methods declared in the class.
\end{mytable}

Chord uses format \code{mName:mDesc@cName} to uniquely identify each
field and each method in the input Java program, where
\code{mName} denotes the name of the field/method,
\code{mDesc} denotes the descriptor of the field/method (see below),
and \code{cName} denotes the fully-qualified name of the class
declaring the field/method.

For instance, ``\code{main:[Ljava/lang/String;@test.HelloWorld}''
uniquely identifies the main method in the example above.

The above format is described in
class \javadoc{chord.program.MethodSign}{chord/program/MethodSign.html}.
We next review field descriptors and method descriptors from the Java
bytecode specification.

A field descriptor represents the type of a local variable or a
(static or instance) field.  It is a series of characters generated by
the grammar:

\begin{framed}
\begin{verbatim}
FieldDescriptor : FieldType
      FieldType : BaseType | ObjectType | ArrayType
       BaseType : B | C | D | F | I | J | S | Z
     ObjectType : L <classname> ;
      ArrayType : [ ComponentType
  ComponentType : FieldType
\end{verbatim}
\end{framed}

The characters of \code{BaseType}, the {\tt L} and {\tt ;}
of \code{ObjectType}, and the {\tt [} of
\code{ArrayType} are all ASCII characters.
The {\tt <classname>} represents a fully qualified class or interface
name.  The interpretation of the field types is as shown in the below
table:

\begin{mytable}{l|l|l}
BaseType Character	& Type	& Interpretation \\
\hline
{\tt B} &byte& signed byte \\
{\tt C} &char& Unicode character \\
{\tt D} &double& double-precision floating-point value \\
{\tt F} &float& single-precision floating-point value \\
{\tt I} &int& integer \\
{\tt J} &long& long integer \\
{\tt L<classname>;}	&reference& an instance of class {\tt <classname>} \\
{\tt S}	&short& signed short \\
{\tt Z}	&boolean& true or false \\
{\tt [}	&reference& one array dimension
\end{mytable}

For example, the descriptor of type {\tt int}
 is simply {\tt I}.  The descriptor of an instance variable of
 type \code{Object} is ``\code{Ljava/lang/Object;}''.  Note that the
 internal form of the fully qualified name for class \code{Object} is
 used. The descriptor of a multidimensional double array of type
 ``\code{double[][][]}'' is ``\code{[[[D}''.

A method descriptor represents the types of the arguments and 
return result of a method:

\begin{framed}
\begin{verbatim}
   MethodDescriptor : ( ParameterDescriptor* ) ReturnDescriptor
ParameterDescriptor : FieldType
   ReturnDescriptor : FieldType | V
\end{verbatim}
\end{framed}

A parameter descriptor represents the type of an argument of a method.
A return descriptor represents the type of the return result of a
method.  The character \code{V} indicates that the method returns no
value (its return type is void).

The method descriptor is the same whether it is a static or an instance
method.  Although an instance method is passed \code{this}, a reference
to the current class instance, in addition to its intended arguments,
that fact is not reflected in the method descriptor.

For example, the method descriptor
for the method ``\code{Object foo(int i, double d, Thread t)}'' is
``\code{(IDLjava/lang/Thread;)Ljava/lang/Object;}''.  Note that
internal forms of the fully qualified names of \code{Thread} and
\code{Object} are used in the method descriptor.

\section{Methods}

The quadcode representation of each method in the input Java program
is a unique \code{jq_Method} object.  Components of a method (e.g.,
its control-flow graph) can be accessed by calling instance methods of
the \code{jq_Method} object representing that method, most notably:

\begin{mytable}{|l|p{3in}|}
\verb+String getName()+ & Name of the method. \\
\hline
\verb+String getDesc().toString()+ & Descriptor of the method, e.g., ``\code{(Ljava/lang/String;)V}''. \\
\hline
\verb+jq_Class getDeclaringClass()+ & Declaring class of the method. \\
\hline
\verb+ControlFlowGraph getCFG()+ & Control-flow graph of the method.* \\
\hline
\verb+int getLineNumber(int bci)+ & The line number of the given bytecode offset. \\
\hline
\verb+Quad getQuad(int bci)+ & The first quad at the given bytecode offset. \\
\hline
\verb+Quad getQuad(int bci, Class kind)+ & The first quad of the given kind at the given bytecode offset. \\
\hline
\verb+Quad getQuad(int bci, Class[] kind)+ & The first quad of any of the given kinds at the given bytecode offset. \\
\hline
\verb+String toString()+ & Unique identifier of the method in format \code{mName:mDesc@cName}.
\end{mytable}

* The control-flow graph must not be asked if the method is abstract (which can be determined by calling instance method \code{isAbstract()} of \code{jq_Method}).

\section{Control-Flow Graphs}

A control-flow graph is a graph whose nodes are basic blocks and whose
edges denote flow of control between basic blocks.

\begin{mytable}{|l|p{4.3in}|}
\verb+getRegisterFactory()+ & \\
\verb+EntryOrExitBasicBlock entry()+ & \\
\verb+EntryOrExitBasicBlock exit()+ & \\
\verb+ListIterator.BasicBlock reversePostOrderIterator()+ & \\
\verb+jq_Method getMethod()+ &
\end{mytable}

basic blocks

\begin{mytable}{|l|p{4.3in}|}
\verb+int size()+ & \\
\verb+Quad getQuad(int index)+ & \\
\verb+ListIterator.BasicBlock getPredecessors().basicBlockIterator()+ &  \\
\verb+ListIterator.BasicBlock getSuccessors().basicBlockIterator()+ & \\
\verb+jq_Method getMethod()+ &
\end{mytable}

\begin{framed}
\begin{verbatim}
ListIterator.BasicBlock it = cfg.reversePostOrderIterator();
while (it.hasNext()) {
    BasicBlock b = it.nextBasicBlock();
    for (int i = 0; i < b.size(); i++) {
        Quad q = b.getQuad(i);
    }
}
\end{verbatim}
\end{framed}

\section{Quads}

\begin{mytable}{|l|p{4.3in}|}
\verb+Operator getOperator()+ & \\
\hline
\verb+jq_Method getMethod()+ & \\
\hline
\verb+int getBCI()+ & \\
\hline
\verb+String toByteLocStr()+ & \code{offset!mName:mDesc@cName} \\
\hline
\verb+String toJavaLocStr()+ & \code{fileName:lineNum}
\hline
\verb+String toLocStr()+ & \\
\hline
\verb+String toVerboseStr()+ &  
\end{mytable}

Chord uses format \code{offset!mName:mDesc@cName} to uniquely identify
each bytecode instruction in the body of each method in the input Java
program, where \code{offset} is the (0-based) bytecode offset of the
instruction in its containing method, \code{mName} is the name of the
method, \code{mDesc} is the descriptor of the method, and \code{cName}
is the fully-qualified name of the class declaring the method.

For instance, ``\code{8!main:[Ljava/lang/String;@test.HelloWorld}''
uniquely identifies the \code{return} instruction in the main method
in the example above.

The above format is described in
class \javadoc{chord.program.MethodElem}{chord/program/MethodElem.html}.

\begin{framed}
\begin{verbatim}
Operator
    |--- Move
    |--- Phi
    |--- Binary
    |--- Unary
    |--- New
    |--- NewAray
    |--- MultiNewArray
    |--- CheckCast
    |--- InstanceOf
    |--- ALength
    |--- ALoad
    |--- AStore
    |--- Getstatic
    |--- Putstatic
    |--- Getfield
    |--- Putfield
    |--- Return
    |--- Branch
    |       |--- IntIfCmp
    |       |--- Goto
    |       |--- Jsr
    |       |--- Ret
    |       |--- LookupSwitch
    |       |--- TableSwitch
    |--- Invoke
    |       |--- InvokeVirtual
    |       |--- InvokeStatic
    |       |--- InvokeInterface
    |--- Monitor
            |--- MONITORENTER
            |--- MONITOREXIT
\end{verbatim}
\end{framed}

explain QuadVisitor and manual switch on Oeprator type, and how to access
all methods of each kind of quad

