\xname{program_representation}
\chapter{Java Program Representation}
\label{chap:program-representation}

Chord uses \xlink{Joeq}{http://joeq.sourceforge.net/} to translate
Java bytecode, one class file at a time, into a three-address-like
intermediate representation of the input Java program called {\it
quadcode}.  This chapter describes how to pretty-print bytecode and
quadcode, which is useful for debugging analyses and deciphering their
output, as well as the API of Joeq and Chord that concerns bytecode
and quadcode, which is useful for users writing their own analyses.

\section{Pretty-Printing Bytecode and Quadcode}

Consider the following Java program contained in
file \code{examples/hello_world/src/test/HelloWorld.java} in Chord's
main directory:
\begin{framed}
\begin{verbatim}
package test;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
\end{verbatim}
\end{framed}

First compile this program by running command \code{ant} in
directory \code{examples/hello_world/}.

To pretty-print the bytecode of a class, run the following command:
\begin{framed}
\begin{verbatim}
javap -classpath <...> -private -verbose <CLASS NAME>
\end{verbatim}
\end{framed}

where {\tt <CLASS NAME>} is the fully-qualified name of the class
whose bytecode is to be printed (\code{test.HelloWorld} in our
example) and \code{<...>} is the classpath of that class
(\code{examples/hello_world/} in our example).  Program \code{javap}
comes along with the JVM.  The output of the above command for our
example is as follows:

\begin{framed}
\begin{verbatim}
Compiled from "HelloWorld.java"
public class test.HelloWorld extends java.lang.Object
  SourceFile: "HelloWorld.java"
  minor version: 0
  major version: 49
  Constant pool:
const #1 = Method   #6.#20; //  java/lang/Object."<init>":()V
const #2 = Field    #21.#22;    //  java/lang/System.out:Ljava/io/PrintStream;
const #3 = String   #23;    //  Hello World!
const #4 = Method   #24.#25;    //  java/io/PrintStream.println:(Ljava/lang/String;)V
const #5 = class    #26;    //  test/HelloWorld
const #6 = class    #27;    //  java/lang/Object
const #7 = Asciz    <init>;
const #8 = Asciz    ()V;
const #9 = Asciz    Code;
const #10 = Asciz   LineNumberTable;
const #11 = Asciz   LocalVariableTable;
const #12 = Asciz   this;
const #13 = Asciz   Ltest/HelloWorld;;
const #14 = Asciz   main;
const #15 = Asciz   ([Ljava/lang/String;)V;
const #16 = Asciz   args;
const #17 = Asciz   [Ljava/lang/String;;
const #18 = Asciz   SourceFile;
const #19 = Asciz   HelloWorld.java;
const #20 = NameAndType #7:#8;//  "<init>":()V
const #21 = class   #28;    //  java/lang/System
const #22 = NameAndType #29:#30;//  out:Ljava/io/PrintStream;
const #23 = Asciz   Hello World!;
const #24 = class   #31;    //  java/io/PrintStream
const #25 = NameAndType #32:#33;//  println:(Ljava/lang/String;)V
const #26 = Asciz   test/HelloWorld;
const #27 = Asciz   java/lang/Object;
const #28 = Asciz   java/lang/System;
const #29 = Asciz   out;
const #30 = Asciz   Ljava/io/PrintStream;;
const #31 = Asciz   java/io/PrintStream;
const #32 = Asciz   println;
const #33 = Asciz   (Ljava/lang/String;)V;

{
public test.HelloWorld();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
   4:   return
  LineNumberTable:
   line 3: 0
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      5      0    this       Ltest/HelloWorld;

public static void main(java.lang.String[]);
  Code:
   Stack=2, Locals=1, Args_size=1
   0:   getstatic   #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   ldc #3; //String Hello World!
   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   8:   return
  LineNumberTable:
   line 5: 0
   line 6: 8
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      9      0    args       [Ljava/lang/String;
}
\end{verbatim}
\end{framed}

To pretty-print the quadcode of a class, run the following command:

\begin{framed}
\begin{verbatim}
ant -Dchord.work.dir=<...> -Dchord.print.classes=<CLASS NAME> \
    -Dchord.verbose=0 -Dchord.out.file=<FILE NAME> run
\end{verbatim}
\end{framed}

where \code{<...>} is the path of a directory
(\code{examples/hello_world/} in our example) that is expected to
contain a file named \code{chord.properties} which defines
properties \code{chord.main.class} and \code{chord.class.path}
specifying the main class and the classpath of the input Java program
(alternatively, these two properties can be defined directly on the
above command line), {\tt <CLASS NAME>} is the name of the class whose
quadcode is to be printed, and {\tt <...>/<FILE NAME>} is the name of
a file to which the quadcode is to be dumped.  The output of the above
command for our example is as follows:

\begin{framed}
\begin{verbatim}
*** Class: test.HelloWorld
Method: main:([Ljava/lang/String;)V@test.HelloWorld
    0#1
    5#3
    5#2
    8#4
Control flow graph for main:([Ljava/lang/String;)V@test.HelloWorld:
BB0 (ENTRY) (in: <none>, out: BB2)

BB2 (in: BB0 (ENTRY), out: BB1 (EXIT))
1: GETSTATIC_A T1, .out
3: MOVE_A T2, AConst: "Hello World!"
2: INVOKEVIRTUAL_V println:(Ljava/lang/String;)V@java.io.PrintStream, (T1, T2)
4: RETURN_V

BB1 (EXIT)  (in: BB2, out: <none>)

Exception handlers: []
Register factory: Registers: 3
\end{verbatim}
\end{framed}

\section{Traversing Quadcode}

\subsection{Program}

\begin{framed}
\begin{verbatim}
package chord.program;

class Program {
    static Program g() {
        // provides quadcode representation of program
    }
    public IndexSet<jq_Type> getTypes() {
        // provides quadcode representation of all reachable types
    }
    public IndexSet<jq_Reference> getClasses() {
        // provides quadcode representation of all reachable classes
    }
    public IndexSet<jq_Method> getMethods() {
        // provides quadcode representation of all reachable methods
    }
    public Reflect getReflect() {
        // provides information about resolved reflection
    }
    public jq_Reference getClass(String name) {
        // provides quadcode representation of class 
    }
    public jq_Type getType(String name) {
    }
    public jq_Method getMainMethod() {
    }
    public jq_Method getMethod(String mName, String mDesc, String cName) {
    }
    public jq_Method getMethod(String sign) {
    }
    public Quad getQuad(MethodElem e) {
    }
    public Quad getQuad(MethodElem e, Class quadOpClass) {
    }
}    
\end{verbatim}
\end{framed}

\subsection{Type}

\begin{framed}
\begin{verbatim}
class jq_Type {
}
\end{verbatim}
\end{framed}

\subsection{Class}

\begin{framed}
\begin{verbatim}
class jq_Reference {
}
\end{verbatim}
\end{framed}

\subsection{Field}

\begin{framed}
\begin{verbatim}
class jq_Field {
     public String getName();
     public jq_Class getDeclaringClass();
     public jq_Type getType() {
     }
     public String toString() {
         // print this field in format fname:fdesc@cname where:
         // - fname is the name of the field
         // - fdesc is the descriptor of the field's type
         // - cname is the name of the field's declaring class
         // example: buf:[B@java.io.BufferedInputStream
     }
}
\end{verbatim}
\end{framed}

\subsection{Method}

\begin{framed}
\begin{verbatim}
class jq_Method {
    
}
\end{verbatim}
\end{framed}

Register Factory

Control-Flow Graph

Basic Block

Quad

\begin{framed}
\begin{verbatim}
Traversing a control-flow graph
\end{verbatim}
\end{framed}

\section{Program Descriptors}

MethodSign

A field descriptor represents the type of a local variable or a
(static or instance) field.  It is a series of characters generated by
the grammar:

\begin{framed}
\begin{verbatim}
FieldDescriptor : FieldType
      FieldType : BaseType | ObjectType | ArrayType
       BaseType : B | C | D | F | I | J | S | Z
     ObjectType : L <classname> ;
      ArrayType : [ ComponentType
  ComponentType : FieldType
\end{verbatim}
\end{framed}

The characters of \code{BaseType}, the {\tt L} and {\tt ;}
of \code{ObjectType}, and the {\tt [} of
\code{ArrayType} are all ASCII characters.
The {\tt <classname>} represents a fully qualified class or interface
name.  The interpretation of the field types is as shown in the below
table:

\begin{table}
\htmlattributes*{table}{border=1 cellpadding=10}
\begin{tabular}{l|l|l}
BaseType Character	& Type	& Interpretation \\
\hline
{\tt B} &byte& signed byte \\
{\tt C} &char& Unicode character \\
{\tt D} &double& double-precision floating-point value \\
{\tt F} &float& single-precision floating-point value \\
{\tt I} &int& integer \\
{\tt J} &long& long integer \\
{\tt L<classname>;}	&reference& an instance of class {\tt <classname>} \\
{\tt S}	&short& signed short \\
{\tt Z}	&boolean& true or false \\
{\tt [}	&reference& one array dimension
\end{tabular}
\end{table}

For example, the descriptor of type {\tt int}
 is simply {\tt I}.  The descriptor of an instance variable of
 type \code{Object} is ``\code{Ljava/lang/Object;}''.  Note that the
 internal form of the fully qualified name for class \code{Object} is
 used. The descriptor of a multidimensional double array of type
 ``\code{double[][][]}'' is ``\code{[[[D}''.

A method descriptor represents the parameters that the method takes
and the value that it returns:

\begin{framed}
\begin{verbatim}
   MethodDescriptor : ( ParameterDescriptor* ) ReturnDescriptor
ParameterDescriptor : FieldType
   ReturnDescriptor : FieldType | V
\end{verbatim}
\end{framed}

A parameter descriptor represents a parameter passed to a method.  A
return descriptor represents the type of the value returned from a
method.  The character \code{V} indicates that the method returns no
value (its return type is void).  For example, the method descriptor
for the method
``\code{Object foo(int i, double d, Thread t)}'' is
``\code{(IDLjava/lang/Thread;)Ljava/lang/Object;}''.
Note that internal forms of the fully qualified names of \code{Thread} and
\code{Object} are used in the method descriptor.  The method descriptor for
\code{foo} is the same whether it is a static or an instance
method. Although an instance method is passed \code{this}, a reference to the
current class instance, in addition to its intended parameters, that
fact is not reflected in the method descriptor.

Chord uniquely represents each bytecode instruction in each method
declared in each class of the program by a
four-tuple \code{bci!mname:mdesc@cname} where \code{bci} is the
(0-based) bytecode offset of the instruction in its containing method,
whose name is \code{mname}, whose descriptor is \code{mname}, and
whose declaring class is \code{cname}.  For
instance, \code{8!main:[Ljava/lang/String;@test.HelloWorld} is the
unique string representation of the \code{return} instruction in the
main method above.
