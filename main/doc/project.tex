\xname{project}
\chapter{A Chord Project: Tasks, Targets, and Dependencies}
\label{chap:project}

In order to facilitate heavy reuse and rapid prototyping, each analysis in Chord is
written modularly, independent of other analyses, along with lightweight annotations
specifying the inputs and outputs of the analysis.
In each run, upon startup, Chord organizes all analyses and their inputs and outputs
(collectively called analysis results) using a global entity
called a {\it project}.  More concretely, a project consists of a set of
analyses called {\it tasks}, a set of analysis results called {\it targets}, and
a set of data/control dependencies between tasks and targets.

The project built in a particular run is of either of two kinds depending upon whether
the value of property \code{chord.classic} is true or false, respectively:
\begin{itemize}
\item
a {\it classic project}, represented as an object of
class \javadoc{chord.project.ClassicProject}{chord/project/ClassicProject.html}.
\item
a {\it modern project}, represented as an object of
class \javadoc{chord.project.ModernProject}{chord/project/ModernProject.html}.
\end{itemize}
The project representation can be obtained by calling static method \code{g()} of the
corresponding class.
A classic project is built by default.
The two kinds of projects differ
primarily in that the only kind of dependencies in a classic
project are data dependencies whereas both data and control dependencies are
allowed in a modern project.  The key advantage of a modern project is that it
can schedule independent tasks in parallel whereas a classic project always
runs tasks sequentially.  This chapter focusses on classic projects as the
runtime for modern projects is still under development.

Class \javadoc{chord.project.ClassicProject}{chord/project/ClassicProject.html}
provides a rich API (in the form of public instance methods) for accessing tasks
and targets in the project, for running tasks, and for resetting tasks and
targets.  The most commonly used methods are as follows:

\begin{mytable}{|l|l|}
\hline
\verb+ITask getTask(String name)+ & Representation of the task named {\tt name}. \\
\hline
\verb+Object getTrgt(String name)+ & Representation of the target named {\tt name}. \\
\hline
\verb+ITask runTask(String name)+ & Execute the task named {\tt name}. \\
\hline
\verb+boolean isTaskDone(String name)+ & Whether task named {\tt name} has alread been executed. \\
\hline
\verb+boolean isTrgtDone(String name)+ & Whether target named {\tt name} has already been computed. \\
\hline
\verb+void resetTaskDone(String name)+ & Force task named {\tt name} to be executed
the next time it is demanded. \\
\hline
\verb+void resetTrgtDone(String name)+ & Force target named {\tt name} to
be computed the next time it is demanded.  \T \\
\hline
\end{mytable}

We explain the meaning of the above methods alongside how Chord builds a project
(a set of tasks, a set of targets, and a set of dependencies between them).

{\bf Tasks:}
Chord provides various {\it analysis templates}: 
classes containing boilerplate code that can be extended by users to rapidly prototype
different kinds of analyses. 
Chapter \ref{chap:writing-analysis} describes the templates.
Each analysis created using any of the templates is a separate task of the
form ``\code{\{ C1, ..., Cn \} T \{ P1, ..., Pm \}}" where:
\begin{itemize}
\item
{\tt T} is the code provided by the user to be executed when the task is executed,
\item
{\tt C1}, ..., {\tt Cn} are the names of zero or more targets specified by the user as being
directly consumed by the task, and
\item
{\tt P1}, ..., {\tt Pm} are the names of zero or more targets specified by the user as being
directly produced by the task.
\end{itemize}
The consumed targets may be produced by other tasks and, likewise, the produced
targets may be consumed by other tasks.

Broadly, there are two kinds of analyses in Chord: those written imperatively in
Java (called Java analyses) and those written declaratively in Datalog (called
Datalog analyses).  Thus, there are two kinds of tasks:

\begin{itemize}

\item

Each \code{@Chord}-annotated class that
occurs in the classpath specified by property \code{chord.java.analysis.path} is
regarded as specifying a separate task.

The name of the task is specified via a statement
\verb+name="<ANALYSIS_NAME>"+ in the {\tt @Chord} annotation.

Chord creates a separate instance of the class to represent the task.

\item

Each file with suffix {\tt .dlog} that occurs in the path specified by
property \code{chord.dlog.analysis.path} is regarded as specifying a separate task.

The name of the task is specified via a standalone ``\verb+# name=<ANALYSIS_NAME>+'' line in the
{\tt .dlog} file.

Chord creates a separate instance of class
\javadoc{chord.project.analyses.DlogAnalysis}{chord/project/analyses/DlogAnalysis.html}
to represent the task.
\end{itemize}

Chord reports a runtime error if multiple tasks have the same name.  The \code{getTask(name)}
method provides the representation of the unique task with the specified name, if it exists,
and a runtime error otherwise.


{\bf Targets:}
The set of targets in a project includes each target that is specified as directly
consumed/produced by some task in the project.  When defining tasks, the user implicitly or
explicitly provides the class (type) of each target.
Chord reports a runtime error if a target has no type or has multiple types.
Otherwise, it creates a separate instance of that class to represent that target.
The \code{getTrgt(name)} method provides the representation of the unique
target with the specified name, if it exists, and a runtime error otherwise.

{\bf Dependencies:}
Chord computes a dependency graph as a directed graph whose
nodes are all tasks and targets computed as above, and:
\begin{itemize}
\item
There is an edge from a target C to a task T if the user has specified that T
directly consumes C.
\item
There is an edge from a task T to a target P is the user has specified that T
directly produces P.
\end{itemize}

We next present an example project to illustrate various concepts in the rest of
this chapter:

\begin{framed}
\begin{verbatim}
{} T1 { R1 }
{} T2 { R2 }
{ R4} T3 { R2 }
{ R1, R2 } T4 { R3, R4 }
\end{verbatim}
\end{framed} 

The set of tasks in this project is \{ {\tt T1}, {\tt T2}, {\tt T3}, {\tt T4} \}
and the set of targets in the project is \{ {\tt R1}, {\tt R2}, {\tt R3}, {\tt R4} \}.
The dependency graph is as follows:

\begin{center}
\includeimage{0.3}{dependency_graph.png}
\end{center}

The \code{runTask(name)} method runs the task with the specified name, if it exists,
and reports a runtime error otherwise.
TODO: explain its meaning w.r.t. example

TODO: explain all 3 kinds of errors

TODO: It is possible to run a task from the command line

%The class must implement
%interface \javadoc{chord.project.ITask}{chord/project/ITask.html}.
