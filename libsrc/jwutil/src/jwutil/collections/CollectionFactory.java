// CollectionFactory.java, created Tue Oct 19 22:21:39 1999 by pnkfelix
// Copyright (C) 1999 Felix S. Klock II <pnkfelix@mit.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package jwutil.collections;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;

import java.io.Serializable;
import jwutil.util.Assert;

/**
 * <code>CollectionFactory</code> is a <code>Collection</code> generator.
 * Subclasses should implement constructions of specific types of
 * <code>Collection</code>s.
 * 
 * Note that since some types of <code>Collection</code> s have implicit
 * constraints (such as <code>Set</code>s, which cannot contain more than one
 * of the same element), code which uses the classes produced by
 * <code>CollectionFactory</code> s must take care not to assume more than
 * what is guaranteed by the <code>Collection</code> interface.
 * 
 * @author Felix S. Klock II <pnkfelix@mit.edu>
 * @version $Id: CollectionFactory.java,v 1.2 2005/04/29 02:32:24 joewhaley Exp $
 */
public abstract class CollectionFactory implements Serializable {
    
    /** Creates a <code>CollectionFactory</code>. */
    public CollectionFactory() { }
    
    /** Generates a new, mutable, empty <code>Collection</code>. */
    public final Collection makeCollection() {
        return makeCollection(Collections.EMPTY_SET);
    }

    /**
     * Generates a new, mutable, empty <code>Collection</code>, using
     * <code>initialCapacity</code> as a hint to use for the capacity for the
     * produced <code>Collection</code>.
     * 
     * @param initialCapacity
     *            hint for initial capacity
     * @return new collection
     */
    public Collection makeCollection(int initialCapacity) {
        return makeCollection();
    }

    /**
     * Generates a new, mutable <code>Collection</code>, using the elements
     * of <code>c</code> as a template for its initial contents. Note that the
     * <code>Collection</code> returned is not a <i>view </i> of
     * <code>c</code>, but rather a snapshot; changes to <code>c</code> are
     * not reflected in the returned <code>Collection</code>.
     * 
     * @param c
     *            collection to snapshot
     * @return new collection
     */
    public abstract Collection makeCollection(Collection c);

    /**
     * Returns a <code>CollectionFactory</code> that generates synchronized
     * (thread-safe) <code>Collection</code>s. The <code>Collection</code>
     * s generated are backed by the <code>Collection</code> s generated by
     * <code>cf</code>.
     * 
     * @see java.util.Collections#synchronizedCollection(java.util.Collection)
     * @param cf
     *            backing collection factory
     * @return new collection factory
     */
    public static CollectionFactory
        synchronizedCollectionFactory(final CollectionFactory cf) { 
        return new SerialCollectionFactory() {
            /**
             * Version ID for serialization.
             */
            private static final long serialVersionUID = 3256721775504209968L;

            public java.util.Collection makeCollection(Collection c) {
                return Collections.synchronizedCollection
                    (cf.makeCollection(c));
            }
        };
    }

    /**
     * Returns a <code>CollectionFactory</code> that generates
     * <code>Collection</code> s that do not allow nulls. If someone attempts
     * to add a null to the collection, an assertion is raised.
     * 
     * @see java.util.Collections#synchronizedCollection(java.util.Collection)
     * @param cf
     *            backing collection factory
     * @return new collection factory
     */
    public static CollectionFactory noNullCollectionFactory(final CollectionFactory cf) {
        return new SerialCollectionFactory() {
            /**
             * Version ID for serialization.
             */
            private static final long serialVersionUID = 3257562919112685113L;

            public Collection makeCollection(final Collection c) {
                Assert._assert(noNull(c));
                final Collection back = cf.makeCollection(c);
                return new CollectionWrapper(back) {
                    public boolean add(Object o) {
                        Assert._assert(o != null);
                        return super.add(o);
                    }
                    public boolean addAll(Collection c2) {
                        Assert._assert(CollectionFactory.noNull(c2));
                        return super.addAll(c2);
                    }
                };
            }
        };
    }

    /**
     * Utility function to check for nulls.
     * 
     * @param c  collection
     * @return  true if there are no nulls in the collection, false otherwise
     */
    private static boolean noNull(Collection c) {
        Iterator iter = c.iterator();
        while (iter.hasNext()) {
            if (iter.next() == null) return false;
        }
        return true;
    }

    // private classes to add java.io.Serializable to *Factories.
    // if we could make anonymous types w/ multiple inheritance, we wouldn't
    // need these.
    private abstract static class SerialCollectionFactory
        extends CollectionFactory implements java.io.Serializable { }
    
}
