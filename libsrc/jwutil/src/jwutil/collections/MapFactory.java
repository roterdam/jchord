// MapFactory.java, created Tue Oct 19 22:42:28 1999 by pnkfelix
// Copyright (C) 1999 Felix S. Klock II <pnkfelix@mit.edu>
// Licensed under the terms of the GNU GPL; see COPYING for details.
package jwutil.collections;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

/**
 * <code>MapFactory</code> is a <code>Map</code> generator.
 * Subclasses should implement constructions of specific types of
 * <code>Map</code>s.
 * <p>
 * Note also that the current limitations on parametric types in
 * Java mean that we can't easily type this class as
 * <code>MapFactory&lt;M extends Map&lt;K,V&gt;,K,V&gt;</code>,
 * as <code>MapFactory&lt;HashMap&lt;K,V&gt;,K,V&gt;</code> is not
 * a subtype of <code>MapFactory&lt;Map&lt;K,V&gt;,K,V&gt;</code>,
 * even though <code>HashMap</code> is a subtype of <code>Map</code>.
 *
 * @author  Felix S. Klock II <pnkfelix@mit.edu>
 * @version $Id: MapFactory.java,v 1.2 2005/04/29 02:32:24 joewhaley Exp $
 */
public abstract class MapFactory/*<K,V>*/ {
    
    /** A <code>MapFactory</code> that generates <code>HashMap</code>s. */ 
    public static final MapFactory hashMapFactory = new SerialMapFactory() {
        /**
         * Version ID for serialization.
         */
        private static final long serialVersionUID = 3834587712341947449L;

        public Map makeMap(java.util.Map map) {
            return new HashMap(map);
        }
    };
    
    /** A <code>MapFactory</code> that generates <code>TreeMap</code>s. */
    public static final MapFactory treeMapFactory = new SerialMapFactory() {
        /**
         * Version ID for serialization.
         */
        private static final long serialVersionUID = 3256446901892494136L;

        public Map makeMap(Map map) {
            return new TreeMap(map);
        }
    };
    
    /** Creates a <code>MapFactory</code>. */
    public MapFactory() {
        
    }

    /** Generates a new, mutable, empty <code>Map</code>. */
    public Map/*<K,V>*/ makeMap() {
        return this.makeMap(Collections.EMPTY_MAP);
    }

    /**
     * Generates a new <code>Map</code>, using the entries of
     * <code>map</code> as a template for its initial mappings. 
     */
    public abstract /*<K2 extends K, V2 extends V>*/ Map/*<K,V>*/ makeMap(Map/*<K2,V2>*/ map);

    /** 
     * Returns a <code>MapFactory</code> that generates synchronized 
     * (thread-safe) <code>Map</code>s.  The <code>Map</code>s
     * generated are backed by the <code>Map</code> generated by
     * <code>mf</code>.
     * @see java.util.Collections#synchronizedMap(java.util.Map)
     */
    public static MapFactory synchronizedMapFactory(final MapFactory mf) {
        return new SerialMapFactory() {
            /**
             * Version ID for serialization.
             */
            private static final long serialVersionUID = 3690472502723752496L;

            public Map makeMap(Map map) {
                return Collections.synchronizedMap(mf.makeMap(map));
            }
        };
    }
    
    // private classes to add java.io.Serializable to *Factories.
    // if we could make anonymous types w/ multiple inheritance, we wouldn't
    // need these.
    private abstract static class SerialMapFactory
    extends MapFactory implements java.io.Serializable { }
    
}
